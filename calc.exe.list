EMU8086 GENERATED LISTING. MACHINE CODE <- SOURCE.
 
calc.exe -- emu8086 assembler version: 4.08  
 
[ 28/12/2024  --  17:33:02 ] 
 
===================================================================================================
[LINE]     LOC: MACHINE CODE                          SOURCE
===================================================================================================
 
[   1]        :                                       ; search for todo's throughout the file
[   2]        :                                       
[   3]        :                                       ; calculator
[   4]        :                                       .MODEL SMALL
[   5]        :                                       
[   6]        :                                       .stack 256
[   7]        :                                       
[   8]        :                                       .DATA
[   9]        :                                       
[  10]        :                                       	; data for result output
[  11]    0100: 00 00 00 00 00 00 00 00 00            	result db length dup(0)		; output result array
[  12]    0109: 00                                    	resultSign db 0			; represents the sign of the result of an operation with unsigned numbers
[  13]    010A: 2D 24                                 	negativeResultString db 45, '$'	; prints a minus '-'
[  14]    010C: 00                                    textOutput db 0			; whether the result is a number resulting of a calculation or text (0: number; 1: text)
[  15]    010D: 00 00                                 textToOutputMemoryAddress dw 0	; specify the memory address of the string to print
[  16]    010F: 56 61 6C 69 64 24                     validString db 'Valid$'
[  17]    0115: 49 6E 76 61 6C 69 64 24               invalidString db 'Invalid$'
[  18]    011D: 49 6E 76 61 6C 69 64 3A 20 64 69 76   divisionByZero db 'Invalid: division by zero$'
                69 73 69 6F 6E 20 62 79 20 7A 65 72 
                6F 24                               
[  19]        :                                       
[  20]        :                                       	; main variables	
[  21]        :                                       	length equ 9			; define constant with the length of the numbers
[  22]        :                                       					; length should be an even number (because of square root algorithm)
[  23]        :                                       	lengthTimesTwo equ length * 2	; for the multiplication result. The maximum size of the result will be the sum of the length of both operands (operands are of the same size, and therefore time 2)		
[  24]    0137: 00 00                                 	inputLoopCounter dw 0		; counter for remaining amount of digit to insert for a number
[  25]    0139: 00 00 00 00 00 00 00 00 00            	numberOne db length dup(0)	; input number 1 array
[  26]    0142: 00 00 00 00 00 00 00 00 00            	numberTwo db length dup(0)	; input number 2 array
[  27]    014B: 00 00                                 	mem1 dw 0	; reserved to reference operand 1 array memory address
[  28]    014D: 00 00                                 	mem2 dw 0	; reserved to reference operand 2 array memory address
[  29]    014F: 00 00                                 	mem3 dw 0	; reserved to reference result array memory address
[  30]    0151: 00 00                                 	tempX dw 0	; used to save the input X coordinated for after the input timeout, cus input timeout overrides cx
[  31]    0153: 00 00                                 	tempY dw 0	; used to save the input Y coordinated for after the input timeout, cus input timeout overrides dx
[  32]    0155: 00                                    	operation db 0			; specifies the operation between the numbers (+, - , /, v (v -> sqrt, only uses one number))	
[  33]    0156: 41 41 41 41 41 41 41 41 41 41         	randomNumberSequence db 10 dup('A')	; contains the numbers for the calculator UI. The numbers won't be printed sequentially
[  34]        :                                       						; the order of the numbers in this array, will be the order the numbers are displayed in the calculator
[  35]    0160: 00 00                                 	mouseInputLastState dw 0
[  36]        :                                       	
[  37]        :                                       	; variable for subtraction
[  38]    0162: 00                                    	anotherCarryFlag db 0		; used in subtraction to define a carry value between iterations		
[  39]        :                                       
[  40]        :                                       	
[  41]        :                                       	; variables for multiplication	
[  42]    0163: 00                                    	anotherCounter db 0	; used for multiplication algorithm	
[  43]    0164: 00 00 00 00 00 00 00 00 00            	tmp1 db length dup(0)	; reserved for mulDiv, carries the result between iterations
[  44]    016D: 00 00 00 00 00 00 00 00 00            	tmp2 db length dup(0)	; reserved for mulDiv, used to subtract the second operand in each iteration
[  45]    0176: 00 00 00 00 00 00 00 00 00            	tmp3 db length dup(0)	; reserved for mulDiv, used to determine the greatest coeficient of divisor (that's it's mutiplication by divisor is lower than the remainder)
[  46]    017F: 00 00 00 00 00 00 00 00 00            	tmp5 db length dup(0)	; reserved for mulDiv, used to copy the second operand into a discartable array
[  47]        :                                       	
[  48]        :                                       	
[  49]        :                                       	; variables for division	
[  50]    0188: 00 00 00 00 00 00 00 00 00            	remainder db length dup(0)	; input number 2 array
[  51]    0191: 00                                    	coeficient db 0			; references the coeficient in the divisor algorithm
[  52]    0192: 00 00 00 00 00 00 00 00 00            	quotient db length dup(0)	; ouput quotient
[  53]    019B: 00                                    	dividendPointer db 0	
[  54]    019C: 00 00 00 00 00 00 00 00 00            	tmp6 db length dup(0)	; reserved for integerDivision, used to copy the coeficient into a discartable array
[  55]    01A5: 00 00 00 00 00 00 00 00 00            	tmp7 db length dup(0)	; reserved for integerDivision, used to copy the second operand into a discartable array
[  56]    01AE: 00 00 00 00 00 00 00 00 00            	tmp4 db length dup(0)	; reserved for integerDivision, used to copy the result value to be then used as param for subtraction
[  57]        :                                       	
[  58]        :                                       	; variables for sqrt
[  59]    01B7: 00 00 00 00 00 00 00 00 00            	root db length dup(0)
[  60]    01C0: 00                                    	rootPointer db 0
[  61]    01C1: 00                                    	rootCoeficient db 0
[  62]    01C2: 00 00 00 00 00 00 00 00 00            	aux db length dup(0)
[  63]    01CB: 00 00 00 00 00 00 00 00 00            	tmp8 db length dup(0)	; reserved for sqrt, contains the base value for each iteration 			
[  64]    01D4: 00 00 00 00 00 00 00 00 00            	tmp9 db length dup(0)	; reserved for sqrt, contains the '2' and rootCoeficient operand
[  65]    01DD: 00 00 00 00 00 00 00 00 00            	tmp10 db length dup(0)	; reserved for sqrt, contains the result of the rootCoeficient addition, will act as input for the rootCoeficient multiplication
[  66]    01E6: 00 00 00 00 00 00 00 00 00            	tmp11 db length dup(0)	; reserved for sqrt, contains the highest tmp value that's also below aux value
[  67]        :                                       	
[  68]        :                                       	; variables for UI
[  69]        :                                       	; the calculator UI is configured for Code Page 437 standard.
[  70]        :                                       	; the symbols in this table are in the equal ascii code number.
[  71]        :                                       	; when running on DOSBOX, the symbols will be rendered according to Code Page 437 standard
[  72]        :                                       	
[  73]        :                                       	; 	Corners
[  74]        :                                       	; ษ -> top left corner
[  75]        :                                       	; ป -> top right corner
[  76]        :                                       	; ศ -> bottom left corner
[  77]        :                                       	; ผ -> bottom right corner
[  78]        :                                       	
[  79]        :                                       	;	lines
[  80]        :                                       	; บ -> Vertical line
[  81]        :                                       	; อ -> Horizontal lines
[  82]        :                                       	
[  83]        :                                       	;	Crosspath corners
[  84]        :                                       	; ฬ -> top, bottom, right
[  85]        :                                       	; ห -> left, bottom, right
[  86]        :                                       	; น -> top, left, bottom
[  87]        :                                       	; ฮ -> top, bottom, right, left
[  88]        :                                       	; ส -> left, top, right
[  89]        :                                       	
[  90]        :                                       	;	Symbols
[  91]        :                                       	;  -> superscript 2
[  92]        :                                       	; ๛ -> root operator symbol	
[  93]        :                                       	; ๛ together act as square root symbol
[  94]        :                                       	
[  95]    01EF:                                       	calculatorUI db "",
[  96]    01EF: C9 CD CD CD CD CD CD CD CD CD CD CD   		db "ษออออออออออออออออออออนSmart Logic Based calculatorฬอออออออออออออออออออป",13,10,
                CD CD CD CD CD CD CD CD CD B9 53 6D 
                61 72 74 20 4C 6F 67 69 63 20 42 61 
                73 65 64 20 63 61 6C 63 75 6C 61 74 
                6F 72 CC CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CD CD BB 0D 
                0A                                  
[  97]    0238: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ                                                                     บ",13,10,
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[  98]    0281: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ                                                                     บ",13,10,
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[  99]    02CA: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ                                                                     บ",13,10,
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 100]    0313: CC CD CD CD CD CD CD CD CD CD CD CD   		db "ฬอออออออออออออออออออออออออออออออออออออออออหอออออออออออออหอออออออออออออน",13,10,
                CD CD CD CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CB CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CB CD CD CD 
                CD CD CD CD CD CD CD CD CD CD B9 0D 
                0A                                  
[ 101]    035C: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ                                         บ             บ             บ",13,10,
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 102]    03A5: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ                                         บ      =      บ     DEL     บ",13,10,
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 3D 20 20 20 20 20 20 BA 20 20 20 
                20 20 44 45 4C 20 20 20 20 20 BA 0D 
                0A                                  
[ 103]    03EE: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ                                         บ             บ             บ",13,10,
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 104]    0437: CC CD CD CD CD CD CD CD CD CD CD CD   		db "ฬอออออออออออออหอออออออออออออหอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
                CD CD CB CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CB CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CE CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CE CD CD CD 
                CD CD CD CD CD CD CD CD CD CD B9 0D 
                0A                                  
[ 105]    0480: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 106]    04C9: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ    EAN13    บ     NIF     บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 45 
                41 4E 31 33 20 20 20 20 BA 20 20 20 
                20 20 4E 49 46 20 20 20 20 20 BA 0D 
                0A                                  
[ 107]    0512: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 108]    055B: CC CD CD CD CD CD CD CD CD CD CD CD   		db "ฬอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
                CD CD CE CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CE CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CE CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CE CD CD CD 
                CD CD CD CD CD CD CD CD CD CD B9 0D 
                0A                                  
[ 109]    05A4: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 110]    05ED: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ     ๛      บ     C C     บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                FD FB 20 20 20 20 20 20 BA 20 20 20 
                20 20 43 20 43 20 20 20 20 20 BA 0D 
                0A                                  
[ 111]    0636: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 112]    067F: CC CD CD CD CD CD CD CD CD CD CD CD   		db "ฬอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
                CD CD CE CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CE CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CE CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CE CD CD CD 
                CD CD CD CD CD CD CD CD CD CD B9 0D 
                0A                                  
[ 113]    06C8: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 114]    0711: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ      +      บ      -      บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 2B 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 2D 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 115]    075A: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 116]    07A3: CC CD CD CD CD CD CD CD CD CD CD CD   		db "ฬอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
                CD CD CE CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CE CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CE CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CE CD CD CD 
                CD CD CD CD CD CD CD CD CD CD B9 0D 
                0A                                  
[ 117]    07EC: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 118]    0835: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ      .      บ     END     บ      *      บ      /      บ",13,10,
                20 20 BA 20 20 20 20 20 20 2E 20 20 
                20 20 20 20 BA 20 20 20 20 20 45 4E 
                44 20 20 20 20 20 BA 20 20 20 20 20 
                20 2A 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 2F 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 119]    087E: BA 20 20 20 20 20 20 20 20 20 20 20   		db "บ             บ             บ             บ             บ             บ",13,10,
                20 20 BA 20 20 20 20 20 20 20 20 20 
                20 20 20 20 BA 20 20 20 20 20 20 20 
                20 20 20 20 20 20 BA 20 20 20 20 20 
                20 20 20 20 20 20 20 20 BA 20 20 20 
                20 20 20 20 20 20 20 20 20 20 BA 0D 
                0A                                  
[ 120]    08C7: C8 CD CD CD CD CD CD CD CD CD CD CD   		db "ศอออออออออออออสอออออออออออออสอออออออออออออสอออออออออออออสอออออออออออออผ$"
                CD CD CA CD CD CD CD CD CD CD CD CD 
                CD CD CD CD CA CD CD CD CD CD CD CD 
                CD CD CD CD CD CD CA CD CD CD CD CD 
                CD CD CD CD CD CD CD CD CA CD CD CD 
                CD CD CD CD CD CD CD CD CD CD BC 24 
                                                    
[ 121]    090F: 00 00                                 	renderTableCurrentRow dw 0	; row guide variable for table output
[ 122]    0911: 04 00                                 	renderTableCurrentColumn dw 4	; column guide variable for table output
[ 123]        :                                       
[ 124]    0913: 02 00                                 inputAreaCurrentRow dw 2	; row guide variable to keep track of the next row when printing digit to input area
[ 125]    0915: 02 00                                 inputAreaCurrentColumn dw 2	; column guide variable to keep track of the next column when printing digit to input area
[ 126]    0917: 00                                    digitToPrint db 0
[ 127]    0918: 0D 0A 24                              newline db 13, 10, '$'			; Carriage Return and Line Feed make up a newline.
[ 128]    091B: 08 20 08 24                           backspace_string db 8, ' ', 8, '$'	; meant to be used for data validation, when user does not press the backspace key
[ 129]    091F: 20 08 24                              removeCurrentCharacter db ' ', 8, '$'   ; meant to be used when user presses the backspace key
[ 130]    0922: 20 24                                 addSpace db 32, '$'			; prints a space ' '
[ 131]        :                                       
[ 132]    0924: 06 00                                 outputAreaCurrentRow dw 6	; row guide variable to keep track of the next row when printing digit to output area
[ 133]    0926: 02 00                                 outputAreaCurrentColumn dw 2	; column guide variable to keep track of the next column when printing digit to output area
[ 134]        :                                       .CODE
[ 135]        :                                       
[ 136]    0930:                                       MAIN PROC
[ 137]    0930: E8 AF 08                              	call config	; initial configurations     			 		
[ 138]        :                                       	
[ 139]    0933: E8 C1 08                              	call generateRandomNumberSequence
[ 140]    0936: E8 EE 08                              call renderUI	; render user interface
[ 141]        :                                       
[ 142]    0939:                                       mainCycle:			
[ 143]        :                                       	       	
[ 144]    0939: E8 BD 0A                              	       	call resetInputTextArea	; remove whatever was rendered withing the input text area	       	 	
[ 145]        :                                       	
[ 146]    093C: BE 39 00                              	lea si, numberOne	; load address of number1 array for input procedure
[ 147]    093F: E8 50 05                              	call zeroNumber		; zero every digit of the array
[ 148]    0942: E8 5A 05                              	call readNumberInput	; read input of first number
[ 149]        :                                       
[ 150]    0945: BE 42 00                              	lea si, numberTwo       ; load address of number2 array for input procedure
[ 151]    0948: E8 47 05                              	call zeroNumber		; zero every digit of the array
[ 152]    094B: E8 51 05                              	call readNumberInput	; read input of second number
[ 153]        :                                       	
[ 154]    094E: E8 30 00                              	call preformOperation	; maps the value in operation to the corresponding procedure
[ 155]        :                                       	
[ 156]    0951: E8 F1 0A                              		call resetOutputTextArea; remove whatever was rendered withing the output text area	         	                                    	
[ 157]        :                                       	
[ 158]    0954: E8 DC 07                              	call printOutput	; renders the result to the console
[ 159]        :                                       
[ 160]        :                                       		; reset variables, the code flow requires these variables to be 0 at the begining of each operation
[ 161]    0957: BE 00 00                              	lea si, result		; zero every digit of the result
[ 162]    095A: E8 35 05                              	call zeroNumber
[ 163]    095D: BE 92 00                              	lea si, quotient        ; zero every digit of the division quotient
[ 164]    0960: E8 2F 05                              	call zeroNumber         		
[ 165]    0963: C6 06 55 00 00                        	mov operation, 0	; zero operation
[ 166]    0968: C6 06 09 00 00                        	mov resultSign, 0       ; set result sign to positive
[ 167]    096D: C6 06 0C 00 00                        	mov textOutput, 0
[ 168]    0972: C7 06 15 08 02 00                     	mov inputAreaCurrentColumn, 2
[ 169]    0978: C7 06 13 08 02 00                     	mov inputAreaCurrentRow, 2       	
[ 170]        :                                       	
[ 171]    097E: EB B9                                 	jmp mainCycle		; repeat
[ 172]    0980: C3                                    	ret
[ 173]        :                                       MAIN ENDP
[ 174]        :                                       
[ 175]        :                                       
[ 176]        :                                       
[ 177]    0981:                                       preformOperation proc
[ 178]        :                                       
[ 179]    0981: BE 39 00                              	lea si, numberOne
[ 180]    0984: 89 36 4B 00                           	mov mem1, si		; first operand
[ 181]        :                                       	
[ 182]    0988: BF 42 00                              	lea di, numberTwo
[ 183]    098B: 89 3E 4D 00                           	mov mem2, di   		; second operand
[ 184]        :                                       	
[ 185]    098F: BB 00 00                              	lea bx, result
[ 186]    0992: 89 1E 4F 00                           	mov mem3, bx
[ 187]        :                                       	
[ 188]    0996: BE 39 00                              	lea si, numberOne
[ 189]    0999: BF 42 00                              	lea di, numberTwo
[ 190]    099C: BB 00 00                              	lea bx, result
[ 191]        :                                       	
[ 192]    099F: 80 3E 55 00 2B                        	cmp operation, '+'
[ 193]    09A4: 75 03 E9 84 04                        	je addNumbers
[ 194]        :                                       	
[ 195]    09A9: 80 3E 55 00 2D                        	cmp operation, '-'
[ 196]    09AE: 75 03 E9 20 04                        	je subNumbers
[ 197]        :                                       	
[ 198]    09B3: 80 3E 55 00 2A                        	cmp operation, '*'
[ 199]    09B8: 75 03 E9 99 03                        	je mulSetup
[ 200]        :                                       	
[ 201]    09BD: 80 3E 55 00 2F                        	cmp operation, '/'
[ 202]    09C2: 75 03 E9 CB 01                        	je integerDivision
[ 203]        :                                       	
[ 204]    09C7: 80 3E 55 00 73                        	cmp operation, 's'
[ 205]    09CC: 74 5C                                 	je sqrt
[ 206]        :                                       	
[ 207]    09CE: 80 3E 55 00 6E                        	cmp operation, 'n'
[ 208]    09D3: 74 01                                 	je nifValidator
[ 209]        :                                       	
[ 210]        :                                       	; cmp operation, 'c'
[ 211]        :                                       	; je ccValidator
[ 212]        :                                       	
[ 213]        :                                       	; cmp operation, 'e'
[ 214]        :                                       	; je ean13BarCodeValidator
[ 215]        :                                       
[ 216]    09D5: C3                                    ret
[ 217]        :                                       preformOperation endp
[ 218]        :                                       
[ 219]        :                                       
[ 220]        :                                       
[ 221]        :                                       
[ 222]    09D6:                                       nifValidator proc
[ 223]        :                                       
[ 224]    09D6: B9 09 00                              mov cx, 9                ; Start multiplier at 9
[ 225]    09D9: BE 42 00                              lea si, numberTwo             ; Point to the start of numberTwo
[ 226]    09DC: BF 00 00                              mov di, 0   ; Initialize result to 0
[ 227]        :                                       
[ 228]    09DF:                                       NIFVALLoop:
[ 229]    09DF: 8A 04                                 mov al, [si]             ; Load current character from arr1
[ 230]    09E1: B4 00                                 mov ah, 0                ; Clear high byte of ax
[ 231]        :                                       
[ 232]    09E3: F7 E1                                 mul cx                   ; Multiply digit by current multiplier
[ 233]    09E5: 03 F8                                 add di, ax  ; Add to the accumulated result
[ 234]        :                                       
[ 235]    09E7: 46                                    inc si                   ; Move to the next digit
[ 236]    09E8: 49                                    dec cx                   ; Decrease the multiplier
[ 237]        :                                       
[ 238]        :                                       ; Stop when cx reaches 1 (multiplier for the last digit)
[ 239]    09E9: 83 F9 01                              cmp cx, 1
[ 240]    09EC: 7F F1                                 jg NIFVALLoop
[ 241]        :                                       
[ 242]        :                                       ; Compute mod 11 of the sum
[ 243]    09EE: 8B C7                                 mov ax, di  ; Load result into ax
[ 244]    09F0: BB 0B 00                              mov bx, 11               ; Divisor for mod operation
[ 245]    09F3: 33 D2                                 xor dx, dx               ; Clear dx for division
[ 246]    09F5: F7 F3                                 div bx                   ; Divide ax by 11 (result in ax, remainder in dx)
[ 247]        :                                       
[ 248]        :                                       ; Compute check digit: 11 - remainder
[ 249]    09F7: B8 0B 00                              mov ax, 11
[ 250]    09FA: 2B C2                                 sub ax, dx               ; ax = 11 - (result mod 11)
[ 251]        :                                       
[ 252]        :                                       ; Adjust check digit if >= 10
[ 253]    09FC: 3D 0A 00                              cmp ax, 10
[ 254]    09FF: 7C 03                                 jl CheckDigitDone
[ 255]    0A01: B8 00 00                              mov ax, 0                ; If result is 10 or 11, check digit is 0
[ 256]        :                                       
[ 257]    0A04:                                       CheckDigitDone:
[ 258]        :                                       ; Compare computed check digit with the last digit of NIF
[ 259]    0A04: BE 42 00                              lea si, numberTwo
[ 260]    0A07: 83 C6 08                              add si, 8                ; Point to the 9th digit (last digit of NIF)
[ 261]    0A0A: 8A 1C                                 mov bl, [si]             ; Load last digit from arr1
[ 262]    0A0C: 3A C3                                 cmp al, bl               ; Compare computed check digit with input
[ 263]    0A0E: 75 0D                                 jne NIFInvalid           ; If not equal, NIF is invalid
[ 264]        :                                       
[ 265]        :                                       ; Valid NIF: Display "NIF is valid!"
[ 266]    0A10: C6 06 0C 00 01                        mov textOutput, 1	; set variable used to validate if it should print the error message in output procedure
[ 267]    0A15: B9 0F 00                              	    lea cx, validString	; load error message of division by zero
[ 268]    0A18: 89 0E 0D 00                           	    mov textToOutputMemoryAddress, cx	; set error message address in appropriate variable for the output procedure
[ 269]        :                                       
[ 270]    0A1C: C3                                    ret
[ 271]        :                                       
[ 272]    0A1D:                                       NIFInvalid:
[ 273]        :                                       ; Invalid NIF: Display "NIF is invalid!"
[ 274]    0A1D: C6 06 0C 00 01                        mov textOutput, 1	; set variable used to validate if it should print the error message in output procedure
[ 275]    0A22: B9 15 00                              	    lea cx, invalidString	; load error message of division by zero
[ 276]    0A25: 89 0E 0D 00                           	    mov textToOutputMemoryAddress, cx	; set error message address in appropriate variable for the output procedure
[ 277]        :                                       
[ 278]        :                                       
[ 279]    0A29: C3                                    ret
[ 280]        :                                       
[ 281]        :                                       
[ 282]        :                                       
[ 283]        :                                       
[ 284]        :                                       nifValidator endp
[ 285]        :                                       
[ 286]        :                                       
[ 287]        :                                       
[ 288]        :                                       
[ 289]        :                                       
[ 290]        :                                       
[ 291]        :                                       
[ 292]        :                                       
[ 293]        :                                       
[ 294]        :                                       
[ 295]        :                                       
[ 296]        :                                       
[ 297]        :                                       
[ 298]        :                                       
[ 299]        :                                       
[ 300]        :                                       
[ 301]        :                                       
[ 302]        :                                       
[ 303]        :                                       
[ 304]        :                                       
[ 305]        :                                       
[ 306]        :                                       
[ 307]        :                                       
[ 308]        :                                       
[ 309]        :                                       
[ 310]        :                                       
[ 311]        :                                       
[ 312]        :                                       
[ 313]    0A2A:                                       sqrt proc
[ 314]    0A2A: BE B7 00                              lea si, root
[ 315]    0A2D: E8 62 04                              call zeroNumber
[ 316]    0A30: BE C2 00                              lea si, aux
[ 317]    0A33: E8 5C 04                              call zeroNumber
[ 318]    0A36: BE CB 00                              	lea si, tmp8
[ 319]    0A39: E8 56 04                              call zeroNumber           		
[ 320]    0A3C: BE D4 00                              lea si, tmp9
[ 321]    0A3F: E8 50 04                              call zeroNumber           		
[ 322]    0A42: BE DD 00                              lea si, tmp10
[ 323]    0A45: E8 4A 04                              call zeroNumber
[ 324]    0A48: C6 06 C0 00 00                        mov rootPointer, 0
[ 325]        :                                       		
[ 326]    0A4D:                                       	updateAux:
[ 327]        :                                       	; multiply by 100 and add the dozens and unit digit -> aux = ( aux * 100 ) + rootPointer[i] + rootPointer[i + 1]	
[ 328]        :                                       	
[ 329]    0A4D:                                       	updateAuxStart:	
[ 330]        :                                       	
[ 331]    0A4D: BF C2 00                              	lea di, aux			
[ 332]    0A50: E8 29 01                              	call multiplyBy100	
[ 333]        :                                       	
[ 334]    0A53: 33 C0                                 	xor ax, ax
[ 335]        :                                       
[ 336]    0A55: BF C9 00                              	lea di, aux + length - 2	; load dozens place
[ 337]        :                                       	
[ 338]        :                                       ; copy dozens digit
[ 339]    0A58: BE 42 00                              lea si, numberTwo	; set si to beggining of number2
[ 340]    0A5B: A0 C0 00                              mov al, rootPointer
[ 341]    0A5E: 03 F0                                 add si, ax		; point to rootPointer offset
[ 342]    0A60: 8A 04                                 mov al, [si]		; indirectly reference value
[ 343]    0A62: 88 05                                 mov [di], al            ; insert number in memory address
[ 344]        :                                       
[ 345]    0A64: FE 06 C0 00                           inc rootPointer
[ 346]    0A68: 47                                    inc di
[ 347]    0A69: 33 C0                                 	xor ax, ax
[ 348]        :                                       	
[ 349]        :                                       ; copy units digit
[ 350]    0A6B: BE 42 00                              lea si, numberTwo	; set si to beggining of number2
[ 351]    0A6E: A0 C0 00                              mov al, rootPointer
[ 352]    0A71: 03 F0                                 add si, ax		; point to rootPointer offset
[ 353]    0A73: 8A 04                                 mov al, [si]            ; indirectly reference value
[ 354]    0A75: 88 05                                 mov [di], al            ; insert number in memory address
[ 355]    0A77: FE 06 C0 00                           inc rootPointer		; this increment will set rootPointer ready for the next iteration
[ 356]        :                                       
[ 357]    0A7B: C6 06 C1 00 00                        	mov rootCoeficient, 0
[ 358]        :                                       	
[ 359]    0A80: BE D4 00                              	lea si, tmp9	
[ 360]    0A83: E8 0C 04                              	call zeroNumber	; set tmp9 to zero before cycle. tmp9 is expected to be 0 at the start
[ 361]        :                                       	        	    	
[ 362]    0A86:                                       	rootMulTable:
[ 363]        :                                       	; 1. calculate tmp value -> tmp = ( ( ( root * 2 ) * 10 ) + i ) * i , with i ranging from 0 to 9. i variable will be called rootCoeficient
[ 364]        :                                       	; 	Calculate ( ( root * 2 ) * 10 ), it will hold the base value for each iteration of the remainging operation with the incrementable variable i
[ 365]        :                                       	;	Do not override the base value, it will be the same for every iteration
[ 366]        :                                       	;	Use the base value, add i and then multiply by i	
[ 367]        :                                       	
[ 368]        :                                       	; 2. on each iteration validate if it's above aux
[ 369]        :                                       	; 2.1 if true, decrease i, and continue to step 3
[ 370]        :                                       	; 2.2 if false, increase i, and re-calculate tmp	
[ 371]        :                                       	
[ 372]    0A86:                                       	rootStepTwoCalculateBaseValue:
[ 373]        :                                       	
[ 374]        :                                       	; 1. calculate tmp value -> tmp = ( ( ( current root value * 2 ) * 10 ) + i ) * 1
[ 375]        :                                       	
[ 376]        :                                       	; ( current root value * 2 )
[ 377]        :                                       	
[ 378]        :                                       	; define second operand '2'		
[ 379]    0A86: BF DC 00                              	lea di, tmp9 + length -	1	; change only the units digit
[ 380]    0A89: C6 05 02                              	mov [di], 2		
[ 381]        :                                       	
[ 382]        :                                       	; preform multiplication -> current root value * 2
[ 383]    0A8C: BF B7 00                              	lea di, root	; indirectly reference root array
[ 384]    0A8F: 89 3E 4B 00                           	mov mem1, di	; divMul input param for first operand
[ 385]        :                                       	
[ 386]    0A93: BF D4 00                              	lea di, tmp9	; indirectly reference tmp9  array
[ 387]    0A96: 89 3E 4D 00                           	mov mem2, di	; divMul input param for second operand
[ 388]        :                                       	
[ 389]    0A9A: BF 00 00                              	lea di, result	; result
[ 390]    0A9D: 89 3E 4F 00                           	mov mem3, di	; divMul input param for result array
[ 391]        :                                       			 			 		      	
[ 392]    0AA1: E8 21 02                              call mulDiv	; multiplicate root by 2	
[ 393]        :                                       
[ 394]        :                                       ; reset auxiliary array
[ 395]    0AA4: BF DC 00                              lea di, tmp9 + length - 1	; only nedeed to change the units digit
[ 396]    0AA7: C6 05 00                              	mov [di], 0	; set tmp9 value back to 0
[ 397]        :                                       	
[ 398]        :                                       	; ( current root value * 2 ) * 10
[ 399]    0AAA: BF 00 00                              	lea di, result
[ 400]    0AAD: E8 BA 00                              	call multiplyBy10
[ 401]        :                                       	
[ 402]        :                                       	; save the base value (current root value * 2)
[ 403]    0AB0: BE 00 00                              	lea si, result
[ 404]    0AB3: BF CB 00                              	lea di, tmp8
[ 405]    0AB6: B9 09 00                              	mov cx, length
[ 406]    0AB9: E8 9C 03                              	call copyArray
[ 407]        :                                       	
[ 408]        :                                       	; reset result
[ 409]    0ABC: BE 00 00                              lea si, result
[ 410]    0ABF: E8 D0 03                              call zeroNumber
[ 411]        :                                       	
[ 412]    0AC2:                                       	iterateOverRootValuePreformOperationAndValidate:
[ 413]        :                                       	
[ 414]        :                                       	        ; reset result
[ 415]    0AC2: BE 00 00                              	lea si, result
[ 416]    0AC5: E8 CA 03                              	call zeroNumber
[ 417]        :                                       	
[ 418]        :                                       		; preform the remaining operations, adding i to the base value and then multiply it by i
[ 419]        :                                       		
[ 420]        :                                       		; add i -> baseValue + i
[ 421]        :                                       		
[ 422]    0AC8: BE CB 00                              		lea si, tmp8			; set first operand, base value
[ 423]    0ACB: BF DC 00                              		lea di, tmp9 + length - 1	; load the place where to put the rootCoeficient value	
[ 424]    0ACE: A0 C1 00                              		mov al,	rootCoeficient		; get rootCoeficient value and put in ax for indirect transfer			
[ 425]    0AD1: 88 05                                 		mov [di], al			; put the root coeficient in the units place of the tmp9 array
[ 426]    0AD3: BF D4 00                              		lea di, tmp9			; set second operand, reset the position to the start of the array
[ 427]    0AD6: BB 00 00                              		lea bx, result			; set result array
[ 428]    0AD9: E8 51 03                              		call addNumbers
[ 429]        :                                       		
[ 430]        :                                       		; save the result in intermediary variable to be used as input for the multiplication
[ 431]    0ADC: BE 00 00                              		lea si, result	; copy origin
[ 432]    0ADF: BF DD 00                              		lea di, tmp10	; copy destination
[ 433]    0AE2: E8 73 03                              		call copyArray	; preform copy
[ 434]        :                                       		
[ 435]        :                                       		; reset result
[ 436]    0AE5: BE 00 00                              		lea si, result
[ 437]    0AE8: E8 A7 03                              		call zeroNumber
[ 438]        :                                       		
[ 439]        :                                       		; multiply by i -> (baseValue + i) * 1
[ 440]    0AEB: BE DD 00                              		lea si, tmp10	; set first operand for multiplication
[ 441]    0AEE: 89 36 4B 00                           		mov mem1, si	; set first operand for multiplication
[ 442]        :                                       		
[ 443]    0AF2: BE DC 00                              		lea si, tmp9 + length - 1	; set value for the second operand for multiplication, root coeficient
[ 444]    0AF5: A0 C1 00                              		mov al,	rootCoeficient
[ 445]    0AF8: 88 04                                 		mov [si], al	; set value for the second operand for multiplication, root coeficient
[ 446]    0AFA: BE D4 00                              		lea si, tmp9
[ 447]    0AFD: 89 36 4D 00                           		mov mem2, si
[ 448]        :                                       		
[ 449]    0B01: BE 00 00                              		lea si, result
[ 450]    0B04: 89 36 4F 00                           		mov mem3, si
[ 451]        :                                       		
[ 452]    0B08: E8 BA 01                              		call muldiv	; preform multiplication				                                				                                		
[ 453]        :                                       	
[ 454]        :                                       	; 2 stop conditions for the coeficient step
[ 455]        :                                       	; Coeficient found or reached max number of iterations. Stop when any of them hits
[ 456]        :                                       	
[ 457]        :                                       	; First
[ 458]        :                                       	; Validate if the result is above to aux ( bx = 1 )
[ 459]        :                                       	; If is is below( bx = 0 ), increase the root coeficient by one and try again
[ 460]        :                                       	; until the result is above or equal to the aux
[ 461]        :                                       	
[ 462]        :                                       	; validate if result is above or equal to the remainder
[ 463]    0B0B: BE C2 00                              	lea si, aux		
[ 464]    0B0E: BF 00 00                              		lea di, result        	        	        	
[ 465]    0B11: E8 5D 03                              	call determineSubtractionSign	; result in bx        	
[ 466]    0B14: 83 FB 01                              	cmp bx, 1
[ 467]    0B17: 74 16                                 	je updateAuxAndRoot        	        	
[ 468]        :                                       	
[ 469]        :                                       	; Second
[ 470]        :                                       	; Stop after 9 was processed has a possible coeficient.
[ 471]        :                                       	; When this happens, the inc below will overflow coeficient by one. We'll fix it a couple lines below
[ 472]    0B19: 80 3E C1 00 0A                        	cmp rootCoeficient, 10
[ 473]    0B1E: 73 0F                                 	jae updateAuxAndRoot        	        	
[ 474]        :                                       	
[ 475]        :                                       	; save the result in intermediary variable to be used to update aux value in step 3
[ 476]    0B20: BE 00 00                              		lea si, result	; copy origin
[ 477]    0B23: BF E6 00                              		lea di, tmp11	; copy destination
[ 478]    0B26: E8 2F 03                              		call copyArray	; preform copy
[ 479]        :                                       		
[ 480]    0B29: FE 06 C1 00                           		inc rootCoeficient				
[ 481]        :                                       		
[ 482]    0B2D: EB 93                                 		jmp iterateOverRootValuePreformOperationAndValidate
[ 483]        :                                       		
[ 484]    0B2F:                                       	updateAuxAndRoot:
[ 485]        :                                       	
[ 486]    0B2F: FE 0E C1 00                           	dec rootCoeficient	; fix rootCoeficient overflow
[ 487]        :                                       	
[ 488]        :                                       	; step 3. Update Aux and Root result
[ 489]        :                                       	
[ 490]        :                                       	; update aux -> aux = aux - tmp
[ 491]        :                                       	; update root -> root = ( root * 10 ) + 1
[ 492]        :                                       	
[ 493]        :                                       	; update aux
[ 494]    0B33: BE C2 00                              	lea si, aux	
[ 495]    0B36: BF E6 00                              	lea di, tmp11   ; result tmp result was saved in tmp10
[ 496]    0B39: BB 00 00                              	lea bx, result
[ 497]    0B3C: E8 58 02                              	call subNumbersMul
[ 498]        :                                       	
[ 499]    0B3F: BE 00 00                              	lea si, result	; copy origin
[ 500]    0B42: BF C2 00                              	lea di, aux	; copy destination
[ 501]    0B45: E8 10 03                              	call copyArray	; preform copy
[ 502]        :                                       	
[ 503]        :                                       	; update root
[ 504]    0B48: BF B7 00                              	lea di, root
[ 505]    0B4B: E8 1C 00                              	call multiplyBy10
[ 506]        :                                       	
[ 507]    0B4E: BF BF 00                              	lea di, root + length - 1
[ 508]    0B51: A0 C1 00                              	mov al, rootCoeficient
[ 509]    0B54: 88 05                                 	mov [di], al
[ 510]        :                                       	
[ 511]        :                                       	; step 4. Validate end of algorithm
[ 512]        :                                       	; if the rootPointer >= length
[ 513]        :                                       	; if yes, finito
[ 514]        :                                       	; if no, increment rootPointer and go to step 2
[ 515]        :                                       	
[ 516]    0B56: 80 3E C0 00 09                        	cmp rootPointer, length
[ 517]    0B5B: 73 03                                 	jae sqrtFinished
[ 518]        :                                       	
[ 519]    0B5D: E9 ED FE                              	jmp updateAux	
[ 520]        :                                       	
[ 521]    0B60:                                       	sqrtFinished:
[ 522]        :                                       	
[ 523]    0B60: BE B7 00                              	lea si, root	; copy origin
[ 524]    0B63: BF 00 00                              	lea di, result	; copy destination
[ 525]    0B66: E8 EF 02                              	call copyArray	; preform copy
[ 526]        :                                       	 	
[ 527]    0B69: C3                                    	ret		
[ 528]        :                                       sqrt endp
[ 529]        :                                       
[ 530]        :                                       
[ 531]        :                                       
[ 532]    0B6A:                                       multiplyBy10 proc
[ 533]        :                                       	
[ 534]        :                                       	; input: di should point to the array start
[ 535]        :                                       
[ 536]        :                                       ; caution: ax is reset in this proc
[ 537]    0B6A: B8 00 00                              mov ax, 0
[ 538]        :                                       
[ 539]        :                                       ; to multiply by 10, we'll shift each element once to the left (excluding right-most element)
[ 540]    0B6D: B9 08 00                              	mov cx, length - 1	; preform one less shift, because that one last shift would pull data from outside the array memory space, this position should be zero				
[ 541]        :                                       		
[ 542]    0B70:                                       	leftShiftAuxMulBy10:		; increase every digit by a order of magnitude
[ 543]    0B70: 8A 45 01                              		mov al, [di + 1]	; get the digit at the right of the current position
[ 544]    0B73: 88 05                                 		mov [di], al            ; override current digit with the one at it's right
[ 545]    0B75: 47                                    		inc di			; move si into the next lower significance digit
[ 546]    0B76: E2 F8                                 		loop leftShiftAuxMulBy10
[ 547]        :                                       	
[ 548]    0B78:                                       	mulByTenUnitDigit:
[ 549]    0B78: C6 05 00                              	mov [di], 0	; set units digit to 0	
[ 550]        :                                       
[ 551]    0B7B: C3                                    	ret
[ 552]        :                                       	
[ 553]        :                                       multiplyBy10 endp
[ 554]        :                                       
[ 555]        :                                       
[ 556]        :                                       
[ 557]    0B7C:                                       multiplyBy100 proc
[ 558]        :                                       	
[ 559]        :                                       	; input: di should point to the array start
[ 560]        :                                       
[ 561]        :                                       	; caution: ax is reset in this proc
[ 562]    0B7C: B8 00 00                              mov ax, 0
[ 563]        :                                       	
[ 564]        :                                       	; to multiply by 100, we'll shift each element twice to the left (excluding left-most two elements)
[ 565]    0B7F: B9 07 00                              	mov cx, length - 2	; preform two less shifts, because those two last shifts would pull data from outside the array bounds
[ 566]        :                                       		
[ 567]    0B82:                                       	leftShiftAuxMulBy100:		; increase every digit by a order of magnitude
[ 568]    0B82: 8A 45 02                              		mov al, [di + 2]	; get the digit at the right of the current position
[ 569]    0B85: 88 05                                 		mov [di], al            ; override current digit with the one at it's right
[ 570]    0B87: 47                                    		inc di			; move si into the next lower significance digit
[ 571]    0B88: E2 F8                                 		loop leftShiftAuxMulBy100
[ 572]        :                                       	
[ 573]    0B8A:                                       	mulByOneHundredUnitAndDozenDigit:
[ 574]    0B8A: C6 05 00                              	mov [di], 0	; set dozens digit to 0
[ 575]        :                                       	
[ 576]    0B8D: 47                                    	inc di		; move to the units digit
[ 577]    0B8E: C6 05 00                              	mov [di], 0	; set units digit to 0
[ 578]        :                                       	
[ 579]    0B91: C3                                    	ret	
[ 580]        :                                       multiplyBy100 endp
[ 581]        :                                       
[ 582]        :                                       
[ 583]        :                                       
[ 584]    0B92:                                       integerDivision proc
[ 585]        :                                       	
[ 586]        :                                       	; validate division by 0 case	
[ 587]    0B92: BF 42 00                              	lea di, numberTwo	; input for proc arrayIsZero
[ 588]    0B95: E8 EC 01                              	call arrayIsZero	; result in dx
[ 589]    0B98: 83 FA 00                              	cmp dx, 0		; dx: 0 -> number is zero ; dx: 1 -> number isn't zero ;
[ 590]    0B9B: 75 0D                                 	jne skipDivisonByZeroSetErrorMessage
[ 591]    0B9D: C6 06 0C 00 01                        	mov textOutput, 1	; set variable used to validate if it should print the error message in output procedure
[ 592]    0BA2: B9 1D 00                              	lea cx, divisionByZero	; load error message of division by zero
[ 593]    0BA5: 89 0E 0D 00                           	mov textToOutputMemoryAddress, cx	; set error message address in appropriate variable for the output procedure
[ 594]    0BA9: C3                                    	ret
[ 595]        :                                       	
[ 596]        :                                       		
[ 597]    0BAA:                                       	skipDivisonByZeroSetErrorMessage:
[ 598]        :                                       		
[ 599]    0BAA: BE 88 00                              	lea si, remainder       ; zero every digit of the remainder         	
[ 600]    0BAD: E8 E2 02                              call zeroNumber
[ 601]    0BB0: C6 06 91 00 00                        mov coeficient, 0       ; zero division quotient
[ 602]    0BB5: C6 06 9B 00 00                        mov dividendPointer, 0                         		
[ 603]        :                                       	
[ 604]        :                                       	; todo validate if divisor is 0
[ 605]        :                                       	
[ 606]    0BBA:                                       	updateRemainder:
[ 607]        :                                       	
[ 608]        :                                       		; update remainder
[ 609]        :                                       		; remainder = remainder * 10 + dividend[dividendPointer]
[ 610]        :                                       	
[ 611]        :                                       		; increase current number in remainder by 1 order of magnitude		
[ 612]    0BBA: BE 88 00                              		lea si, remainder	; start at the leftmost position of the array and override it with the next digit
[ 613]    0BBD: BA 00 00                              		mov dx, 0		; reset dx
[ 614]    0BC0: 8A 16 9B 00                           		mov dl, dividendPointer
[ 615]    0BC4: BF 39 00                              		lea di, numberOne
[ 616]    0BC7: 03 FA                                 		add di, dx              ; move di into the dividend unit defined by dividend pointer
[ 617]    0BC9: B9 08 00                              		mov cx, length - 1	; preform one less shift, because that one last shift would pull data from outside the array memory space				
[ 618]        :                                       		
[ 619]    0BCC:                                       		leftShiftRemainder:		; increase every digit by a order of magnitude
[ 620]    0BCC: 8A 44 01                              			mov al, [si + 1]	; get the digit at the right of the current position
[ 621]    0BCF: 88 04                                 			mov [si], al            ; override current digit with the one at it's right
[ 622]    0BD1: 46                                    			inc si			; move si into the next lower significance digit
[ 623]    0BD2: E2 F8                                 			loop leftShiftRemainder	; repeat for remaining digits
[ 624]        :                                       			
[ 625]        :                                       		; add the unit digit
[ 626]    0BD4: 8A 05                                 		mov al, [di]	; select the digit from dividend to put in the units place of remainder
[ 627]    0BD6: 88 04                                 		mov [si], al	; move into the remainder
[ 628]        :                                       		
[ 629]        :                                       		; determine if the remainder is greater or equal to the divisor
[ 630]    0BD8: BE 88 00                              		lea si, remainder	
[ 631]    0BDB: BF 42 00                              		lea di, numberTwo
[ 632]        :                                       		
[ 633]    0BDE: E8 90 02                              		call determineSubtractionSign ; determine if the remainder is above or equal to the divisor (0 greater or equal, 1 below)
[ 634]        :                                       		
[ 635]    0BE1: 83 FB 00                              		cmp bx, 0 ; if bx is 0, the remainder is above or equal to the divisor
[ 636]    0BE4: 74 0F                                 		je determineDivisorCoeficient
[ 637]        :                                       		
[ 638]    0BE6: 8A 16 9B 00                           		mov dl, dividendPointer ; dividend pointer
[ 639]    0BEA: 80 FA 08                              	cmp dl, length - 1	; stop when the dividen pointer value reached the length of the dividend
[ 640]    0BED: 74 06                                 		je determineDivisorCoeficient
[ 641]        :                                       		     		
[ 642]    0BEF: FE 06 9B 00                           		inc dividendPointer
[ 643]    0BF3: EB C5                                 		jmp updateRemainder		
[ 644]        :                                       	     	
[ 645]        :                                       	
[ 646]    0BF5:                                       	determineDivisorCoeficient:	; find the greatest coeficient of divisor such that it's below or equal to the remainder
[ 647]        :                                       	
[ 648]        :                                       	        ; WARNING: do not change coeficient to cx cus it calls the determineSubtractionSign and it overrides cx. using coeficient is safe
[ 649]        :                                       	        ; starting at 0 and incrementing. Starting at 9 will take longer most of the times
[ 650]    0BF5: C6 06 91 00 00                        		mov coeficient, 0	; divisor coeficient (0, 1, 2, ..., 8, 9)
[ 651]        :                                       		
[ 652]    0BFA:                                       		findDivisorCoeficient:
[ 653]        :                                       			; in order to use multiplication, both operands need to be arrays of digits
[ 654]        :                                       			; we're mapping our multiplication increment to an array and send it as that
[ 655]    0BFA: BF 7E 00                              			lea di, tmp3 + length - 1	; load the address of the last (rightmost, least significant) element of tmp3 array. Used to represent the coeficient number in an array	
[ 656]    0BFD: A0 91 00                              			mov al, coeficient
[ 657]    0C00: 88 05                                 			mov [di], al		; move the coeficient value into least significant position of tmp array
[ 658]        :                                       					
[ 659]    0C02: BF 42 00                              			lea di, numberTwo	; divisior
[ 660]    0C05: 89 3E 4B 00                           			mov mem1, di
[ 661]        :                                       	
[ 662]    0C09: BF 76 00                              			lea di, tmp3		; coeficient
[ 663]    0C0C: 89 3E 4D 00                           			mov mem2, di
[ 664]        :                                       	
[ 665]    0C10: BF 00 00                              			lea di, result		; result
[ 666]    0C13: 89 3E 4F 00                           			mov mem3, di
[ 667]        :                                       			 			 		      	
[ 668]    0C17: E8 AB 00                              		call mulDiv		; multiplicate coeficient by divisor      		
[ 669]        :                                       		
[ 670]        :                                       		; validate if result is above or equal to the remainder
[ 671]    0C1A: BE 88 00                              		lea si, remainder
[ 672]    0C1D: BF 00 00                              			lea di,	result	  	
[ 673]    0C20: E8 4E 02                              		call determineSubtractionSign	; result in bx
[ 674]        :                                       		
[ 675]        :                                       		; reset result
[ 676]    0C23: BE 00 00                              		lea si, result
[ 677]    0C26: E8 69 02                              		call zeroNumber			; procedure cannot affect bx value
[ 678]        :                                       		
[ 679]        :                                       		; 2 stop conditions for the coeficient step
[ 680]        :                                       		; Coeficient found or reached max number of iterations. Stop when any of them hits
[ 681]        :                                       	
[ 682]        :                                       		; First
[ 683]        :                                       		; Validate if the mutiplication of the coeficient by the divisor is above to the remainder
[ 684]        :                                       		; If is coeficient multiplication is below than the remainder ( bx = 0 ), increase the coeficient by one and try again
[ 685]        :                                       		; until the coeficient multiplication * divisor is above to the remainder
[ 686]    0C29: 83 FB 01                              		cmp bx, 1
[ 687]    0C2C: 74 0B                                 		je updateRemainderAndQuotient         		        	        		
[ 688]        :                                       		
[ 689]        :                                       		; Second
[ 690]        :                                       		; Stop after 9 was processed has a possible coeficient.
[ 691]        :                                       		; When this happens, the inc below will overflow coeficient by one. We'll fix it a couple lines below
[ 692]    0C2E: 80 3E 91 00 09                        		cmp coeficient, 9
[ 693]    0C33: FE 06 91 00                           		inc coeficient        		        	
[ 694]    0C37: 76 C1                                 		jbe findDivisorCoeficient
[ 695]        :                                       	
[ 696]        :                                       	        ; coeficient overflows by one (to 10). Maximum number of coeficient is 9. This because we're using the decimal numebr system nerd
[ 697]        :                                       	        ; dec coeficient	; correct overflow of coeficient
[ 698]        :                                       	
[ 699]        :                                       	
[ 700]    0C39:                                       	updateRemainderAndQuotient:
[ 701]        :                                       		
[ 702]    0C39: FE 0E 91 00                           		dec coeficient
[ 703]        :                                       		
[ 704]        :                                       		; increase current quotient by 1 order of magnitude (multiplication by 10)
[ 705]    0C3D: B9 08 00                              		mov cx, length - 1	; preform one less shift, because that one last shift would pull data from outside the array memory space				
[ 706]    0C40: BE 92 00                              		lea si, quotient	
[ 707]        :                                       	
[ 708]    0C43:                                       	leftShiftRemainderDiv:		; increase every digit by a order of magnitude
[ 709]    0C43: 8A 44 01                              			mov al, [si + 1]	; get the digit at the right of the current position
[ 710]    0C46: 88 04                                 			mov [si], al            ; override current digit with the one at it's right
[ 711]    0C48: 46                                    			inc si			; move si into the next lower significance digit
[ 712]    0C49: E2 F8                                 			loop leftShiftRemainderDiv	; repeat for remaining digits
[ 713]        :                                       	
[ 714]        :                                       	; add the units value to the quotient
[ 715]    0C4B: A0 91 00                              	mov al, coeficient
[ 716]    0C4E: 88 04                                 	mov [si], al
[ 717]        :                                       	
[ 718]    0C50: BE 00 00                              	lea si, result		
[ 719]    0C53: E8 3C 02                              	call zeroNumber		; reset result array
[ 720]        :                                       	        	
[ 721]        :                                       	; update remainder
[ 722]        :                                       	
[ 723]    0C56: BF A4 00                              	lea di, tmp6 + length - 1
[ 724]    0C59: A0 91 00                              	mov al, coeficient		; mov coeficient into intermediary register
[ 725]    0C5C: 88 05                                 		mov [di], al
[ 726]    0C5E: B0 00                                 		mov al, 0
[ 727]    0C60: BF 9C 00                              	lea di, tmp6
[ 728]    0C63: 89 3E 4B 00                           	mov mem1, di
[ 729]        :                                       	
[ 730]        :                                       	; copy divisor into tmp6, and use tmp as second operand for multiplication        	
[ 731]    0C67: BE 42 00                              	lea si, numberTwo	; copy from divisor
[ 732]    0C6A: BF A5 00                              	lea di, tmp7 		; copy to discartable array (value in this array will be zeroed)
[ 733]    0C6D: B9 09 00                              	mov cx, length		; result
[ 734]    0C70: E8 E5 01                              	call copyArray        	
[ 735]    0C73: BF A5 00                              	lea di, tmp7
[ 736]    0C76: 89 3E 4D 00                           	mov mem2, di            ; use tmp array, (because subNumber decrements)
[ 737]        :                                       	
[ 738]    0C7A: BF 00 00                              	lea di, result
[ 739]    0C7D: 89 3E 4F 00                           		mov mem3, di
[ 740]        :                                       		       	
[ 741]    0C81: E8 41 00                              	call mulDiv
[ 742]        :                                       	
[ 743]    0C84: BE 00 00                              	lea si, result		; copy from
[ 744]    0C87: BF AE 00                              	lea di, tmp4		; copy to
[ 745]    0C8A: B9 09 00                              	mov cx, length		; result
[ 746]    0C8D: E8 C8 01                              	call copyArray
[ 747]        :                                       	
[ 748]    0C90: BE 88 00                              	lea si, remainder
[ 749]    0C93: BF AE 00                              	lea di, tmp4
[ 750]    0C96: BB 00 00                              		lea bx, result       	
[ 751]    0C99: E8 FB 00                              	call subNumbersMul
[ 752]        :                                       	
[ 753]    0C9C: BE 00 00                              	lea si, result		; copy from
[ 754]    0C9F: BF 88 00                              	lea di, remainder	; copy to
[ 755]    0CA2: B9 09 00                              	mov cx, length		; result
[ 756]    0CA5: E8 B0 01                              	call copyArray        	
[ 757]        :                                       	
[ 758]    0CA8: 8A 16 9B 00                           	mov dl, dividendPointer ; dividend pointer
[ 759]    0CAC: 80 FA 08                              	cmp dl, length - 1	; stop when the dividen pointer value reached the lengt of the dividend
[ 760]    0CAF: FE 06 9B 00                           	inc dividendPointer
[ 761]    0CB3: 73 03 E9 02 FF                        	jb updateRemainder     ; do another iteration
[ 762]        :                                       		
[ 763]    0CB8:                                       		divisionFinished:      	
[ 764]        :                                       	
[ 765]    0CB8: BE 92 00                              	lea si, quotient	; copy from result
[ 766]    0CBB: BF 00 00                              	lea di, result		; copy to quotient
[ 767]    0CBE: B9 09 00                              	mov cx, length		; result
[ 768]    0CC1: E8 94 01                              	call copyArray
[ 769]        :                                       	
[ 770]    0CC4: C3                                    ret
[ 771]        :                                       integerDivision endp
[ 772]        :                                       
[ 773]        :                                       
[ 774]        :                                       
[ 775]    0CC5:                                       mulDiv proc	
[ 776]        :                                       	
[ 777]        :                                       	; Multiplication is implemented by adding the same number a bunch of times
[ 778]        :                                       	; 2 * 3, is done by adding the number 2, 3 times.
[ 779]        :                                       	; 2 * 3 = ( ( ( 0 + 2 = 2 ) + 2 = 4 ) + 2 = 6 )
[ 780]        :                                       	; The zero is the begining state of the result, when the additions are complete,
[ 781]        :                                       	; the result variable already contains the value.
[ 782]        :                                       	; The number of times the addition happens is the value of the second operand (passed in tmp3)
[ 783]        :                                       	; on each iteration, we subtract that value by 1.
[ 784]        :                                       	; We preform this while the second operand is different from zero
[ 785]        :                                       	
[ 786]        :                                       	; input
[ 787]        :                                       	; mem1, address of the first element of the array representing the first operand
[ 788]        :                                       	; mem2, address of the first element of the array representing the second operand
[ 789]        :                                       	; mem3, address of the result array
[ 790]        :                                       		
[ 791]        :                                       	; this is a destructive procedure. The second operand will be changed, and because of such,
[ 792]        :                                       	; before the algorithm starts, the second operand will be copied to tmp5 and will use that instead.
[ 793]        :                                       	
[ 794]        :                                       	; tmp1 used to save the consecutive additions on each iteration
[ 795]        :                                       	; tmp2 used to represent the number 1 to subtract the divisor on each iteration
[ 796]        :                                       	; tmp3 contains the remainign additions left to complete the multiplication
[ 797]        :                                       	; tmp5 second operand is copied into a discartable
[ 798]        :                                       	
[ 799]        :                                       	; backup second operand in tmp5 array
[ 800]    0CC5: 8B 1E 4D 00                           	mov bx, mem2		; reference mem2 (memory address of second operand)
[ 801]    0CC9: 8D 37                                 	lea si, [bx]		; indirectly reference mem2 value
[ 802]    0CCB: BF 7F 00                              	lea di, tmp5		; copy second operand into discartable array
[ 803]    0CCE: B9 09 00                              	mov cx, length
[ 804]    0CD1: E8 84 01                              call copyArray		; copy from array in si to array in di
[ 805]        :                                       	
[ 806]    0CD4:                                       	additionCycleMulDiv:
[ 807]        :                                       	     	 				
[ 808]        :                                       		
[ 809]        :                                       		; validate if we have any addition to preform , input di register		 		
[ 810]    0CD4: BF 7F 00                              		lea di, tmp5		; number of additions left to preform
[ 811]    0CD7: E8 AA 00                              		call arrayIsZero	; validate
[ 812]    0CDA: 83 FA 00                              		cmp dx, 0
[ 813]    0CDD: 74 5B                                 		je mulCompleteMulDiv	; if zero, no addition remains. Exit the addition loop
[ 814]        :                                       		
[ 815]        :                                       		; load input variables into apropriate register
[ 816]    0CDF: 8B 1E 4B 00                           		mov bx, mem1		; reference mem1 (first operand array memory address)
[ 817]    0CE3: 8D 37                                 		lea si, [bx]		; indirectly reference mem1 value     							
[ 818]    0CE5: 8B 1E 4F 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 819]    0CE9: 8D 1F                                 		lea bx, [bx]		; indirectly reference mem3 value		                                                                           	
[ 820]        :                                       		
[ 821]        :                                       		; Access the result from the previous iteration (in tmp1) and store it in the result. If it's the first iteration, tmp1 array is all zeros
[ 822]    0CEB: BE 64 00                              		lea si, tmp1		; copy value from previous iteration
[ 823]    0CEE: 8B 1E 4F 00                           		mov bx, mem3		; into reference memory mem3 (result variable array memory address)
[ 824]    0CF2: 8D 3F                                 		lea di, [bx]		; indirectly reference mem3
[ 825]    0CF4: B9 09 00                              		mov cx, length
[ 826]    0CF7: E8 5E 01                              		call copyArray		; execute copy
[ 827]        :                                       
[ 828]        :                                       		; preform one addition		
[ 829]    0CFA: 8B 1E 4B 00                           		mov bx, mem1		; reference mem1 (first operand array memory address)
[ 830]    0CFE: 8D 37                                 		lea si, [bx]		; indirectly reference mem1 value
[ 831]    0D00: 8B 1E 4F 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 832]    0D04: 8D 3F                                 		lea di, [bx]		; indirectly reference mem3 value		
[ 833]    0D06: E8 24 01                              		call addNumbers		; execute addition
[ 834]        :                                       		
[ 835]        :                                       		; save result for the next iteration. Subtraction will override the result variable
[ 836]    0D09: 8B 1E 4F 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 837]    0D0D: 8D 37                                 		lea si, [bx]
[ 838]    0D0F: BF 64 00                              		lea di, tmp1		; save the result for next interation
[ 839]    0D12: B9 09 00                              		mov cx, length
[ 840]    0D15: E8 40 01                              		call copyArray		
[ 841]        :                                       				
[ 842]    0D18: BE 7F 00                              		lea si, tmp5		;
[ 843]    0D1B: C6 06 75 00 01                        		mov [tmp2 + length - 1], 1	; setup array representing number 1		
[ 844]    0D20: BF 6D 00                              		lea di, tmp2		; load array memory address for subtraction	
[ 845]    0D23: 8B 1E 4F 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 846]    0D27: 8D 1F                                 		lea bx, [bx]
[ 847]    0D29: E8 6B 00                              		call subNumbersMul	; execute subtraction
[ 848]        :                                       		
[ 849]        :                                       		; subtraction saved the result in the result variable
[ 850]        :                                       		; for the algorithm, the numberTwo itself needs to be
[ 851]        :                                       		; the one decremented, so we're going to copy the value
[ 852]        :                                       		; from result to numberTwo
[ 853]        :                                       		
[ 854]    0D2C: BE 00 00                              		lea si, result		
[ 855]    0D2F: BF 7F 00                              		lea di, tmp5
[ 856]    0D32: B9 09 00                              		mov cx, length
[ 857]    0D35: E8 20 01                              		call copyArray
[ 858]        :                                       		
[ 859]    0D38: EB 9A                                 		jmp additionCycleMulDiv	
[ 860]        :                                       	
[ 861]    0D3A:                                       	mulCompleteMulDiv:
[ 862]        :                                       	
[ 863]    0D3A: BE 64 00                              	lea si, tmp1
[ 864]    0D3D: 8B 1E 4F 00                           	mov bx, mem3		
[ 865]    0D41: 8D 3F                                 	lea di, [bx]
[ 866]    0D43: B9 09 00                              	mov cx, length
[ 867]    0D46: E8 0F 01                              	call copyArray
[ 868]        :                                       	
[ 869]        :                                       	; zero out accumulator array
[ 870]    0D49: BE 64 00                              	lea si, tmp1
[ 871]    0D4C: E8 43 01                              	call zeroNumber
[ 872]        :                                       	
[ 873]        :                                       	; zero out subtraction tmp array
[ 874]    0D4F: BE 75 00                              	lea si, tmp2 + length - 1
[ 875]    0D52: C6 04 00                              	mov [si], 0	
[ 876]        :                                       	
[ 877]    0D55: C3                                    	ret
[ 878]        :                                       mulDiv endp
[ 879]        :                                       
[ 880]        :                                       
[ 881]        :                                       
[ 882]    0D56:                                       mulSetup proc
[ 883]        :                                       
[ 884]    0D56: BE 39 00                              	lea si, numberOne
[ 885]    0D59: 89 36 4B 00                           	mov mem1, si
[ 886]        :                                       	
[ 887]    0D5D: BF 42 00                              	lea di, numberTwo
[ 888]    0D60: 89 3E 4D 00                           	mov mem2, di
[ 889]        :                                       	
[ 890]    0D64: BB 00 00                              	lea bx, result
[ 891]    0D67: 89 1E 4F 00                           	mov mem3, bx	   	
[ 892]        :                                       	
[ 893]    0D6B: E8 57 FF                              	call mulDiv
[ 894]        :                                       
[ 895]    0D6E: C3                                    	ret
[ 896]        :                                       mulSetup endp
[ 897]        :                                       
[ 898]        :                                       
[ 899]        :                                       
[ 900]    0D6F:                                       lengthOfNumber proc
[ 901]        :                                       
[ 902]        :                                       ; this procedure counts the number of significant digits in the array (does not count leading zeros)
[ 903]        :                                       
[ 904]        :                                       ; input: si points to the array
[ 905]        :                                       ; output: dx will contains the number of digits of the number
[ 906]        :                                       
[ 907]    0D6F: B9 00 00                              mov cx, 0
[ 908]    0D72: B1 09                                 	mov cl, length
[ 909]    0D74: BA 00 00                              	mov dx, 0
[ 910]        :                                       	
[ 911]    0D77:                                       	countDigitsOfNumber:
[ 912]        :                                       	
[ 913]    0D77: 80 3C 00                              		cmp [si], 0
[ 914]    0D7A: 75 03                                 		jne notLeadingZero
[ 915]        :                                       	
[ 916]    0D7C: 46                                    	        inc si
[ 917]        :                                       	
[ 918]    0D7D: E2 F8                                 		loop countDigitsOfNumber
[ 919]        :                                       		
[ 920]    0D7F:                                       		notLeadingZero:
[ 921]    0D7F: B2 09                                 		mov dl, length
[ 922]    0D81: 2A D1                                 		sub dl, cl
[ 923]        :                                       		
[ 924]    0D83: C3                                    	ret
[ 925]        :                                       
[ 926]        :                                       lengthOfNumber endp
[ 927]        :                                       
[ 928]        :                                       
[ 929]        :                                       
[ 930]    0D84:                                       arrayIsZero proc
[ 931]        :                                       	; compares each digit to zero
[ 932]        :                                       	; if every single one of them is zero, at the end
[ 933]        :                                       	; dx will contain a 0, otherwise, dx will contain a 1
[ 934]        :                                       	
[ 935]        :                                       	; input data:
[ 936]        :                                       	; di : points to the start of the number array
[ 937]        :                                       	
[ 938]        :                                       	; output data:   	
[ 939]        :                                       	; dx : output ( 0 : array represents a zero number  |  1 : array represents a non-zero number )
[ 940]        :                                       	
[ 941]    0D84: BA 00 00                              	mov dx, 0
[ 942]    0D87: B9 09 00                              	mov cx, length
[ 943]        :                                       	
[ 944]    0D8A:                                       	validate:
[ 945]    0D8A: 80 3D 00                              		cmp [di], 0	; compare digit to zero
[ 946]    0D8D: 75 04                                 		jne notZero	; if the digit in not a zero, exit the loop and mark the flag as 1 ( 1: array is a non-zero number)
[ 947]        :                                       	
[ 948]    0D8F: 47                                    	        inc di		; move to next digit
[ 949]        :                                       		
[ 950]    0D90: E2 F8                                 		loop validate	
[ 951]        :                                       	
[ 952]    0D92: C3                                    	ret
[ 953]        :                                       		
[ 954]    0D93:                                       	notZero:
[ 955]    0D93: BA 01 00                              	mov dx, 1    	
[ 956]    0D96: C3                                    	ret
[ 957]        :                                       arrayIsZero endp
[ 958]        :                                       
[ 959]        :                                       
[ 960]        :                                       
[ 961]    0D97:                                       subNumbersMul proc
[ 962]        :                                       						
[ 963]    0D97: F8                                    	clc		; Clear Carry Flag (cf = 0)
[ 964]    0D98: B8 00 00                              	mov ax, 0	; clear ax
[ 965]        :                                       	
[ 966]    0D9B: 83 C6 08                              	add si, length - 1	; put si in the memory address of the last element of the numerOne array
[ 967]    0D9E: 83 C7 08                              	add di, length - 1	; put di in the memory address of the last element of the numerTwo array
[ 968]    0DA1: 80 C3 08                              	add bl, length - 1	; put bx in the memory address of the last element of the result array	
[ 969]        :                                       
[ 970]    0DA4: B9 09 00                              	mov cx, length	
[ 971]        :                                       		
[ 972]    0DA7:                                       	subElementsMul:	
[ 973]    0DA7: 8A 04                                 		mov al, [si]
[ 974]    0DA9: 3A 05                                 		cmp al, [di]
[ 975]    0DAB: 73 11                                 		jae subDontSetCarryMul
[ 976]        :                                       			
[ 977]    0DAD: 04 0A                                 		add al, 10	; minuend below subtrahend, so add the to the minuend ; this add overrides the default carry flag. bugs out the sbb operations below		
[ 978]        :                                       		
[ 979]    0DAF:                                       		subSetCarryMul:	
[ 980]    0DAF: 2A 05                                 		sub al, [di]			; subtract values and carry
[ 981]    0DB1: 2A 06 62 00                           		sub al, anotherCarryFlag	; subtract the carry from the previous subtraction
[ 982]    0DB5: C6 06 62 00 01                        		mov anotherCarryFlag, 1		; set carry flag for subtraction
[ 983]    0DBA: 88 07                                 		mov [bx], al			; move the subtraction result to the corresponding element of the result array
[ 984]    0DBC: EB 0D                                 		jmp subContinueMul
[ 985]        :                                       		
[ 986]    0DBE:                                       		subDontSetCarryMul:
[ 987]    0DBE: 2A 05                                 		sub al, [di]			; move the subtraction result to the corresponding element of the result array
[ 988]    0DC0: 2A 06 62 00                           		sub al, anotherCarryFlag	; subtract the carry from the previous subtraction
[ 989]    0DC4: C6 06 62 00 00                        		mov anotherCarryFlag, 0		; clear carry flag for subtraction
[ 990]    0DC9: 88 07                                 		mov [bx], al			; move the subtraction result to the corresponding element of the result array
[ 991]        :                                       		
[ 992]        :                                       		
[ 993]    0DCB:                                       		subContinueMul:
[ 994]    0DCB: 4E                                    		dec si		; move si pointer to the left element of the array (one order greater)
[ 995]    0DCC: 4F                                    		dec di		; move di pointer to the left element of the array (one order greater)
[ 996]    0DCD: 4B                                    		dec bx		; move bx pointer to the left element of the array (one order greater)
[ 997]    0DCE: B0 00                                 		mov al, 0	; clear ax for following operations
[ 998]        :                                       	
[ 999]    0DD0: E2 D5                                 loop subElementsMul
[1000]        :                                       			       	
[1001]    0DD2: C3                                    	ret	
[1002]        :                                       subNumbersMul endp
[1003]        :                                       
[1004]        :                                       
[1005]        :                                       
[1006]    0DD3:                                       subNumbers proc
[1007]        :                                       	; TODO write some bs about how the algorithm requires a positive result
[1008]        :                                       	; TODO the minuend as to be greater or equal to the subtrahend explain that
[1009]        :                                       	; TODO yeah also describe the subtraction algorithm
[1010]        :                                       	
[1011]        :                                       	; How to deal with negative results.
[1012]        :                                       	; Subtraction is not a commutative operation, but there is a direct relation in the result if we swap the operands.
[1013]        :                                       	; If we swap the operands, the result is going to have the same absolute value, but the symmetric sign.
[1014]        :                                       	; The sign of the the result can be predicted by the order of the operands
[1015]        :                                       	; if the minuend is below the subtrahend, we're facing a negative result
[1016]        :                                       	; Knowing both this things, we will predict when the subtraction would result in a signed negative value and react accordingly
[1017]        :                                       	; If the result is negative, we will swap the operands resulting in a signed positive and set a flag to represent the result is unsigned negative
[1018]        :                                       	
[1019]    0DD3: BE 39 00                              	lea si, numberOne 	; put si in the memory address of the fist element of the numerOne array
[1020]    0DD6: BF 42 00                              	lea di, numberTwo	; put di in the memory address of the fist element of the numerTwo array
[1021]        :                                       	
[1022]    0DD9: E8 95 00                              	call determineSubtractionSign	; signed subtraction is not suported. We will predict the sign of the result and if it's negative swap the operands
[1023]        :                                       	
[1024]    0DDC: 83 FB 00                              	cmp bx, 0
[1025]    0DDF: 74 10                                 	je skipOperandSwap
[1026]        :                                       	
[1027]        :                                       	; to not deal with a negative result, we will swap the operands and have a flag representing a negative result 	
[1028]    0DE1: 88 1E 09 00                           	mov resultSign, bl	; set negative number flag
[1029]        :                                       	
[1030]    0DE5: B9 09 00                              	mov cx, length
[1031]    0DE8: BE 39 00                              	lea si, numberOne
[1032]    0DEB: BF 42 00                              	lea di, numberTwo
[1033]        :                                       	
[1034]    0DEE: E8 73 00                              	call swapDigitsBetweenNumbers			
[1035]        :                                       		
[1036]    0DF1:                                       	skipOperandSwap:
[1037]    0DF1: F8                                    	clc		; Clear Carry Flag (cf = 0)
[1038]    0DF2: B8 00 00                              	mov ax, 0	; clear ax
[1039]        :                                       	
[1040]    0DF5: BE 41 00                              	lea si, numberOne + length - 1	; put si in the memory address of the last element of the numerOne array
[1041]    0DF8: BF 4A 00                              	lea di, numberTwo + length - 1  ; put di in the memory address of the last element of the numerTwo array
[1042]    0DFB: BB 08 00                              	lea bx, result + length - 1	; put bx in the memory address of the last element of the result array	
[1043]        :                                       	
[1044]    0DFE: B9 09 00                              	mov cx, length	; loop should repeat for the size of the array
[1045]        :                                       	
[1046]    0E01:                                       	subElements:		
[1047]        :                                       		; To deal with negative results on each iteration, we're going to avoid them alltogether.
[1048]        :                                       		; Negative results in subtraction happen when we subtract a digit by a larger one, so
[1049]        :                                       		; we're going to validate if the minuend digit is below the subtrahend digit and if so
[1050]        :                                       		; add 10 to the minuend value, set a carry flag for later and then preform the subtraction
[1051]        :                                       		; The carry flag will be subtracted to the minuend in the following iteration
[1052]        :                                       		
[1053]    0E01: 8A 04                                 		mov al, [si]
[1054]    0E03: 3A 05                                 		cmp al, [di]
[1055]    0E05: 73 11                                 		jae subDontSetCarry
[1056]        :                                       		
[1057]    0E07: 04 0A                                 		add al, 10	; minuend below subtrahend, so add the to the minuend ; this add overrides the default carry flag. bugs out the sbb operations below		
[1058]        :                                       	
[1059]    0E09:                                       		subSetCarry:	
[1060]    0E09: 2A 05                                 		sub al, [di]			; subtract values and carry
[1061]    0E0B: 2A 06 62 00                           		sub al, anotherCarryFlag	; subtract the carry from the previous subtraction
[1062]    0E0F: C6 06 62 00 01                        		mov anotherCarryFlag, 1		; set carry flag for subtraction
[1063]    0E14: 88 07                                 	        mov [bx], al			; move the subtraction result to the corresponding element of the result array
[1064]    0E16: EB 0D                                 	        jmp subContinue
[1065]        :                                       	
[1066]    0E18:                                       	        subDontSetCarry:
[1067]    0E18: 2A 05                                 	        sub al, [di]			; move the subtraction result to the corresponding element of the result array
[1068]    0E1A: 2A 06 62 00                           	        sub al, anotherCarryFlag        ; subtract the carry from the previous subtraction
[1069]    0E1E: C6 06 62 00 00                        	        mov anotherCarryFlag, 0		; clear carry flag for subtraction
[1070]    0E23: 88 07                                 	        mov [bx], al			; move the subtraction result to the corresponding element of the result array
[1071]        :                                       	
[1072]        :                                       	
[1073]    0E25:                                       	        subContinue:
[1074]    0E25: 4E                                    	        dec si		; move si pointer to the left element of the array (one order greater)
[1075]    0E26: 4F                                    	        dec di  	; move di pointer to the left element of the array (one order greater)
[1076]    0E27: 4B                                    	        dec bx  	; move bx pointer to the left element of the array (one order greater)
[1077]    0E28: B0 00                                 	        mov al, 0	; clear ax for following operations
[1078]        :                                       	
[1079]    0E2A: E2 D5                                 		loop subElements			       	
[1080]    0E2C: C3                                    	ret	
[1081]        :                                       subNumbers endp
[1082]        :                                       
[1083]        :                                       
[1084]        :                                       
[1085]    0E2D:                                       addNumbers proc
[1086]        :                                       	
[1087]    0E2D: F8                                    	clc		; Clear Carry Flag (cf = 0)
[1088]    0E2E: B8 00 00                              	mov ax, 0	; clear ax
[1089]        :                                       	
[1090]    0E31: 83 C6 08                              	add si, length - 1		; put si in the memory address of the last element of the first array
[1091]    0E34: 83 C7 08                              	add di, length - 1  		; put di in the memory address of the last element of the second array
[1092]    0E37: BB 08 00                              	lea bx, result + length - 1	; put bx in the memory address of the last element of the result array	
[1093]        :                                       	
[1094]    0E3A: B9 09 00                              	mov cx, length	; loop should repeat for the size of the array
[1095]        :                                       	
[1096]    0E3D:                                       	addElements:
[1097]    0E3D: 8A 04                                 		mov al, [si]	; add a digit of first number
[1098]    0E3F: 12 05                                 		adc al, [di]    ; add a digit of first number
[1099]        :                                       	
[1100]    0E41: 3C 0A                                 	        cmp al, 10      ; check if the result is greater than or equal to 10
[1101]    0E43: 72 07                                 		jb no_carry     ; if not, skip carry adjustment
[1102]        :                                       		
[1103]    0E45:                                       		carry:	
[1104]    0E45: 2C 0A                                 		sub al, 10      ; adjust the result to fit in a single decimal digit
[1105]    0E47: F9                                    		stc             ; SeT Carry Flag (cf = 1)
[1106]    0E48: 88 07                                 	        mov [bx], al    ; move the sum to the corresponding element of the result array
[1107]    0E4A: EB 03                                 	        jmp continue
[1108]        :                                       	
[1109]    0E4C:                                       	        no_carry:
[1110]    0E4C: F8                                    	        clc             ; Clear Carry Flag (cf = 0)
[1111]    0E4D: 88 07                                 	        mov [bx], al    ; move the sum to the corresponding element of the result array
[1112]        :                                       	
[1113]    0E4F:                                       	        continue:
[1114]    0E4F: 4E                                    	        dec si		; move si pointer to the left element of the array (one order greater)
[1115]    0E50: 4F                                    	        dec di 		; move di pointer to the left element of the array (one order greater)
[1116]    0E51: 4B                                    	        dec bx  	; move bx pointer to the left element of the array (one order greater)
[1117]    0E52: B8 00 00                              	        mov ax, 0	; clear ax for following operations
[1118]        :                                       	
[1119]    0E55: E2 E6                                 		loop addElements
[1120]        :                                       	
[1121]    0E57: C3                                    	ret	
[1122]        :                                       addNumbers endp
[1123]        :                                       
[1124]        :                                       
[1125]        :                                       
[1126]    0E58:                                       copyArray proc
[1127]        :                                       
[1128]        :                                       	; si : array to copy values from
[1129]        :                                       	; di : array to copy values to	
[1130]        :                                       	; deprecated; cx : length of the arrays
[1131]    0E58: B9 09 00                              	mov cx, length
[1132]        :                                       	
[1133]    0E5B:                                       	doCopy:
[1134]    0E5B: 8A 04                                 		mov al, [si]
[1135]    0E5D: 88 05                                 		mov [di], al
[1136]        :                                       		
[1137]    0E5F: 46                                    		inc si
[1138]    0E60: 47                                    		inc di
[1139]        :                                       		
[1140]    0E61: E2 F8                                 		loop doCopy		
[1141]    0E63: C3                                    	ret
[1142]        :                                       copyArray endp
[1143]        :                                       
[1144]        :                                       
[1145]        :                                       
[1146]    0E64:                                       swapDigitsBetweenNumbers proc
[1147]        :                                       
[1148]        :                                       	; swap array specified by si and di register
[1149]        :                                       	; cx must contain the length of the arrays
[1150]        :                                       
[1151]    0E64:                                       	doSwap:
[1152]    0E64: 8A 04                                 		mov al, [si]
[1153]    0E66: 8A 1D                                 		mov bl, [di]
[1154]    0E68: 88 1C                                 		mov [si], bl
[1155]    0E6A: 88 05                                 		mov [di], al
[1156]    0E6C: 46                                    		inc si
[1157]    0E6D: 47                                    		inc di
[1158]    0E6E: E2 F4                                 		loop doSwap
[1159]        :                                       		
[1160]    0E70: C3                                    	ret		
[1161]        :                                       swapDigitsBetweenNumbers endp
[1162]        :                                       
[1163]        :                                       
[1164]        :                                       
[1165]    0E71:                                       determineSubtractionSign proc
[1166]        :                                       
[1167]        :                                       ; compare arrays in SI and DI
[1168]        :                                       
[1169]        :                                       ; on procedure end, SI and DI are not within their initial array bounds
[1170]        :                                       
[1171]    0E71: B8 00 00                              mov ax, 0		; zero register
[1172]    0E74: BB 00 00                              mov bx, 0		; bx contains the subtraction result sign (0 positive or zero result, 1 negative result)  	
[1173]        :                                       	
[1174]    0E77: B9 09 00                              mov cx, length		; preform the validation for each digit. The amount of digits in a number is specified by length
[1175]        :                                       
[1176]    0E7A:                                       compareDigitsToValidateSubtraction:
[1177]        :                                       	; to validate if the number in si is above or equal to the number in di. Numbers are arrays of the same length.
[1178]        :                                       	; we're going to validate if each digit of number1 is above or equal to the corresponding magnitude digit of number2.
[1179]        :                                       	; When the validation fails, up to that point the number1 digits are either above or equal to the digits of number2,
[1180]        :                                       	; and on the moment the validation fails, the number2 is above of number1
[1181]        :                                       	; we will stop here and mark the flag (bx) as 1 (negative)
[1182]        :                                       	
[1183]        :                                       		; cmp [si], [di] error. CMP cannot take both operands to be memory references
[1184]        :                                       		
[1185]    0E7A: 8A 05                                 		mov al, [di]
[1186]    0E7C: 38 04                                 		cmp [si], al
[1187]    0E7E: 77 06                                 		ja positiveResultDetected	; number1 digit must be above to the corresponding magnitude digit of number2 to result positive
[1188]        :                                       	 	
[1189]    0E80: 74 08                                 	 	je compareNextDigits            ; if digits are equal, the result will be determined through the remainding less significative digits
[1190]        :                                       	 	
[1191]    0E82:                                       		negativeResultDetected:
[1192]    0E82: BB 01 00                              		mov bx, 1	; validation flag contains subtraction result sign (0 positive result, 1 negative result)		 		 		
[1193]    0E85: C3                                    		ret		; no point continuing the validation for the remaining digits.
[1194]        :                                       		
[1195]    0E86:                                       		positiveResultDetected:
[1196]    0E86: BB 00 00                              		mov bx, 0	; validation flag contains subtraction result sign (0 positive result, 1 negative result)		 		 		
[1197]    0E89: C3                                    		ret		; no point continuing the validation for the remaining digits.
[1198]        :                                       		                      		
[1199]    0E8A:                                       		compareNextDigits:
[1200]    0E8A: 46                                    		inc si
[1201]    0E8B: 47                                    		inc di
[1202]        :                                       		 		
[1203]    0E8C: E2 EC                                 		loop compareDigitsToValidateSubtraction
[1204]        :                                       		
[1205]        :                                       		; if reached here, subtraction results is zero
[1206]        :                                       		
[1207]    0E8E: BB 00 00                              		mov bx, 0
[1208]        :                                       		
[1209]    0E91: C3                                    	ret
[1210]        :                                       determineSubtractionSign endp
[1211]        :                                       
[1212]        :                                       
[1213]    0E92:                                       zeroNumber proc
[1214]        :                                       	
[1215]        :                                       	; input: number to reset is defined by the addresss in si
[1216]        :                                       	; after function: si register points to the start of the array
[1217]        :                                       	
[1218]    0E92: B9 09 00                              	mov cx, length
[1219]        :                                       	
[1220]        :                                       	; si points to the biggining of the array
[1221]        :                                       	
[1222]    0E95:                                       	zeroDigit:
[1223]    0E95: C6 04 00                              		mov [si], 0
[1224]    0E98: 46                                    		inc si
[1225]    0E99: E2 FA                                 		loop zeroDigit
[1226]        :                                       	
[1227]        :                                       	; WARNING: do not add -1 to length. The previous loop makes si overflow the array by one position
[1228]        :                                       	; and therefore, subtracting si by length returns to the first element of the array
[1229]    0E9B: 83 EE 09                              	sub si, length	
[1230]        :                                       			
[1231]    0E9E: C3                                    	ret
[1232]        :                                       zeroNumber endp
[1233]        :                                       
[1234]        :                                       
[1235]    0E9F:                                       readNumberInput PROC
[1236]        :                                       	
[1237]        :                                       	; the number will be stored in an arbitrary array
[1238]        :                                       	; the array will be defined by the address in the SI register
[1239]        :                                       	; should be of the address of the first element in the array	   	    	
[1240]        :                                       	
[1241]        :                                       	; set max amount of digits per number
[1242]    0E9F: B9 09 00                              	mov cx, length	
[1243]    0EA2: 89 0E 37 00                           	mov inputLoopCounter, cx	; max digits in the number	         				
[1244]        :                                       	
[1245]    0EA6:                                       	readingDigit:
[1246]        :                                       		
[1247]    0EA6: B8 01 00                              		mov ax, 0001h	; show mouse
[1248]    0EA9: CD 33                                 		int 33h
[1249]        :                                       		
[1250]    0EAB: B8 03 00                              		mov ax, 3	; get mouse coordinates sub-function
[1251]    0EAE: CD 33                                 		int 33h		; execute	
[1252]        :                                       		
[1253]    0EB0: 83 FB 01                              		cmp bx, 1
[1254]    0EB3: 75 F1                                 		jne readingDigit
[1255]        :                                       		
[1256]    0EB5: 89 0E 51 00                           		mov tempX, cx	; backup X coordinate, input timeout overrides cx
[1257]    0EB9: 89 16 53 00                           		mov tempY, dx	; backup y coordinate, input timeout overrides dx
[1258]        :                                       		
[1259]        :                                       		; fix mouse click eco
[1260]    0EBD: B9 03 00                              		mov cx, 0003h	; around .6 seconds timeout
[1261]    0EC0: BA 00 00                              		mov dx, 0h
[1262]        :                                       		
[1263]    0EC3: B4 86                                 		mov ah, 86h
[1264]    0EC5: CD 15                                 		int 15h		; execute timeout
[1265]        :                                       		
[1266]    0EC7: 8B 0E 51 00                           		mov cx, tempX	; restore X coordindate to register
[1267]    0ECB: 8B 16 53 00                           		mov dx, tempY	; restore Y coordindate to register
[1268]        :                                       		
[1269]    0ECF: D1 E9 D1 E9 D1 E9                     		shr cx, 3	; divide by 8 for 80x25 screen
[1270]    0ED5: D1 EA D1 EA D1 EA                     		shr dx, 3       ; divide by 8 for 80x25 screen
[1271]        :                                       		; --------------------------------- Validate for invalid input coordinates -------------------------------------	
[1272]        :                                       		
[1273]    0EDB: 83 F9 05                              		cmp cx, 5	; out-of-bounds left
[1274]    0EDE: 76 C6                                 		jbe readingDigit
[1275]        :                                       		
[1276]    0EE0: 83 F9 4A                              		cmp cx, 74	; out-of-bounds right
[1277]    0EE3: 73 C1                                 		jae readingDigit
[1278]        :                                       		
[1279]    0EE5: 83 FA 01                              		cmp dx, 1	; out-of-bounds upper
[1280]    0EE8: 76 BC                                 		jbe readingDigit
[1281]        :                                       		
[1282]    0EEA: 83 FA 18                              		cmp dx, 24	; out-of-bounds below
[1283]    0EED: 73 B7                                 		jae readingDigit
[1284]        :                                       		
[1285]    0EEF: 83 FA 08                              		cmp dx, 8	; border horizontal
[1286]    0EF2: 74 B2                                 		je readingDigit
[1287]        :                                       		
[1288]    0EF4: 83 FA 0C                              		cmp dx, 12	; border horizontal
[1289]    0EF7: 74 AD                                 		je readingDigit
[1290]        :                                       		
[1291]    0EF9: 83 FA 10                              		cmp dx, 16	; border horizontal
[1292]    0EFC: 74 A8                                 		je readingDigit
[1293]        :                                       		
[1294]    0EFE: 83 FA 14                              		cmp dx, 20	; border horizontal
[1295]    0F01: 74 A3                                 		je readingDigit
[1296]        :                                       		
[1297]    0F03: 83 F9 12                              		cmp cx, 18	; border vertical
[1298]    0F06: 74 9E                                 		je readingDigit
[1299]        :                                       		
[1300]    0F08: 83 F9 20                              		cmp cx, 32	; border vertical
[1301]    0F0B: 74 99                                 		je readingDigit
[1302]        :                                       		
[1303]    0F0D: 83 F9 2E                              		cmp cx, 46	; border vertical
[1304]    0F10: 74 94                                 		je readingDigit
[1305]        :                                       		
[1306]    0F12: 83 F9 3C                              		cmp cx, 60	; border vertical
[1307]    0F15: 74 8F                                 		je readingDigit  		
[1308]        :                                       		
[1309]        :                                       		; invalid coordinates should have been filtered out
[1310]        :                                       		; now, validate which option has been clicked
[1311]        :                                       		
[1312]    0F17:                                       		validateSecondRow:
[1313]    0F17: 83 FA 08                              		cmp dx, 8
[1314]    0F1A: 77 28                                 		ja validateThirdRow
[1315]    0F1C: 83 F9 12                              			cmp cx, 18
[1316]    0F1F: 77 04                                 			ja validateSecondRowSecondColumn; if click is outside second row first column area
[1317]    0F21: B0 00                                 			mov al, 0		; click coordinates does not match to any option
[1318]    0F23: EB 81                                 			jmp readingDigit
[1319]        :                                       			
[1320]    0F25:                                       			validateSecondRowSecondColumn:		
[1321]    0F25: 83 F9 20                              			cmp cx, 32
[1322]    0F28: 77 05                                 			ja validateSecondRowThirdColumn	; if click is outside second row second column area	
[1323]    0F2A: B0 00                                 			mov al, 0		; click coordinates does not match to any option
[1324]    0F2C: E9 77 FF                              			jmp readingDigit
[1325]        :                                       			
[1326]    0F2F:                                       			validateSecondRowThirdColumn:
[1327]    0F2F: 83 F9 2E                              			cmp cx, 46
[1328]    0F32: 77 05                                 			ja validateSecondRowForthColumn ; if click is outside second row third column area
[1329]    0F34: B0 00                                 			mov al, 0		; click coordinates does not match to any option
[1330]    0F36: E9 6D FF                              			jmp readingDigit
[1331]        :                                       			
[1332]    0F39:                                       			validateSecondRowForthColumn:
[1333]    0F39: 83 F9 3C                              			cmp cx, 60
[1334]    0F3C: 77 03                                 			ja validateSecondRowFifthColumn	; if click is outside second row forth column area
[1335]    0F3E: E9 9D 01                              			jmp inputIsFinished	; '=' was pressed
[1336]        :                                       			
[1337]    0F41:                                       			validateSecondRowFifthColumn:	
[1338]    0F41: E9 5D 01                              			jmp isBackspace	; 'DEL' was pressed
[1339]        :                                       			
[1340]        :                                       					
[1341]    0F44:                                       		validateThirdRow:
[1342]    0F44: 83 FA 0C                              		cmp dx, 12
[1343]    0F47: 77 50                                 		ja validateForthRow
[1344]    0F49: 83 F9 12                              			cmp cx, 18
[1345]    0F4C: 77 08                                 			ja validateThirdRowSecondColumn
[1346]    0F4E: BB 56 00                              			lea bx, randomNumberSequence
[1347]    0F51: 8A 07                                 			mov al, [bx]		; number selector, first row left cell, select first index of randomNumberSequence
[1348]    0F53: E9 6E 01                              			jmp numberIsValid
[1349]        :                                       			
[1350]    0F56:                                       			validateThirdRowSecondColumn:		
[1351]    0F56: 83 F9 20                              			cmp cx, 32
[1352]    0F59: 77 08                                 			ja validateThirdRowThirdColumn
[1353]    0F5B: BB 57 00                              			lea bx, randomNumberSequence + 1
[1354]    0F5E: 8A 07                                 			mov al, [bx]		; number selector, first row mid cell, select second index of randomNumberSequence
[1355]    0F60: E9 61 01                              			jmp numberIsValid
[1356]        :                                       			
[1357]    0F63:                                       			validateThirdRowThirdColumn:
[1358]    0F63: 83 F9 2E                              			cmp cx, 46
[1359]    0F66: 77 08                                 			ja validateThirdRowForthColumn
[1360]    0F68: BB 58 00                              			lea bx, randomNumberSequence + 2
[1361]    0F6B: 8A 07                                 			mov al, [bx]		; number selector, first row right cell, select third index of randomNumberSequence
[1362]    0F6D: E9 54 01                              			jmp numberIsValid
[1363]        :                                       			
[1364]    0F70:                                       			validateThirdRowForthColumn:
[1365]    0F70: 83 F9 3C                              			cmp cx, 60
[1366]    0F73: 77 12                                 			ja validateThirdRowFifthColumn
[1367]    0F75: 80 3E 55 00 00                        			cmp operation, 0
[1368]    0F7A: 74 03 E9 5F 01                        	   		jne inputIsFinished	; operation has already been set.	
[1369]    0F7F: C6 06 55 00 65                        	   		mov operation, 'e'	; set ean-13 barcode validation	   		
[1370]    0F84: E9 57 01                              	   		jmp inputIsFinished
[1371]        :                                       		
[1372]        :                                       			
[1373]    0F87:                                       			validateThirdRowFifthColumn:
[1374]    0F87: 80 3E 55 00 00                        			cmp operation, 0
[1375]    0F8C: 74 03 E9 4D 01                        	   		jne inputIsFinished	; operation has already been set.	
[1376]    0F91: C6 06 55 00 6E                        	   		mov operation, 'n'	; set nif validation   		
[1377]    0F96: E9 45 01                              	   		jmp inputIsFinished 	
[1378]        :                                       		
[1379]        :                                       		
[1380]    0F99:                                       		validateForthRow:
[1381]    0F99: 83 FA 10                              		cmp dx, 16
[1382]    0F9C: 77 51                                 		ja validateFifthRow
[1383]    0F9E: 83 F9 12                              			cmp cx, 18
[1384]    0FA1: 77 08                                 			ja validateForthRowSecondColumn
[1385]    0FA3: BB 59 00                              			lea bx, randomNumberSequence + 3
[1386]    0FA6: 8A 07                                 			mov al, [bx]		; number selector, seocnd row left cell, select forth index of randomNumberSequence
[1387]    0FA8: E9 19 01                              			jmp numberIsValid
[1388]        :                                       			
[1389]    0FAB:                                       			validateForthRowSecondColumn:		
[1390]    0FAB: 83 F9 20                              			cmp cx, 32
[1391]    0FAE: 77 08                                 			ja validateForthRowThirdColumn
[1392]    0FB0: BB 5A 00                              			lea bx, randomNumberSequence + 4
[1393]    0FB3: 8A 07                                 			mov al, [bx]		; number selector, second row mid cell, select fifth index of randomNumberSequence
[1394]    0FB5: E9 0C 01                              			jmp numberIsValid
[1395]        :                                       			
[1396]    0FB8:                                       			validateForthRowThirdColumn:
[1397]    0FB8: 83 F9 2E                              			cmp cx, 46
[1398]    0FBB: 77 08                                 			ja validateForthRowForthColumn
[1399]    0FBD: BB 5B 00                              			lea bx, randomNumberSequence + 5
[1400]    0FC0: 8A 07                                 			mov al, [bx]		; number selector, second row right cell, select sixth index of randomNumberSequence
[1401]    0FC2: E9 FF 00                              			jmp numberIsValid			
[1402]        :                                       			
[1403]    0FC5:                                       			validateForthRowForthColumn:
[1404]    0FC5: 83 F9 3C                              			cmp cx, 60
[1405]    0FC8: 77 22                                 			ja validateForthRowFifthColumn
[1406]    0FCA: 80 3E 55 00 00                        			cmp operation, 0
[1407]    0FCF: 74 03 E9 0A 01                        	   		jne inputIsFinished	; operation has already been set.	
[1408]    0FD4: C6 06 55 00 73                        	   		mov operation, 's'	; set sqrt operation
[1409]    0FD9: C6 06 17 08 CD                        	   		mov digitToPrint, '' - 48	; print operator. proc used mainly for numbers (used with ascii 0 - 9)
[1410]    0FDE: E8 25 01                              	   		call printInputDigit	
[1411]    0FE1: C6 06 17 08 CB                        	   		mov digitToPrint, '๛' - 48	; print operator. proc used mainly for numbers (used with ascii 0 - 9)
[1412]    0FE6: E8 1D 01                              	   		call printInputDigit	   		
[1413]    0FE9: E9 F2 00                              	   		jmp inputIsFinished
[1414]        :                                       	   		
[1415]    0FEC:                                       			validateForthRowFifthColumn:
[1416]        :                                       		        ;cmp operation, 0
[1417]        :                                       	   		;jne inputIsFinished	; operation has already been set.	
[1418]        :                                       	   		;mov operation, 'c'	   		
[1419]        :                                       	   		;jmp inputIsFinished
[1420]    0FEC: E9 B7 FE                              		        jmp readingDigit	; do not preform cc validation for now, cc required keyboard input. As of now, it doesn't work in conjunction with mouse input
[1421]        :                                       
[1422]        :                                       		
[1423]    0FEF:                                       		validateFifthRow:
[1424]    0FEF: 83 FA 14                              		cmp dx, 20
[1425]    0FF2: 77 60                                 		ja validateSixthRow
[1426]    0FF4: 83 F9 12                              			cmp cx, 18
[1427]    0FF7: 77 08                                 			ja validateFifthRowSecondColumn
[1428]    0FF9: BB 5C 00                              			lea bx, randomNumberSequence + 6
[1429]    0FFC: 8A 07                                 			mov al, [bx]		; number selector, third row left cell, select seventh index of randomNumberSequence
[1430]    0FFE: E9 C3 00                              			jmp numberIsValid			
[1431]        :                                       			
[1432]    1001:                                       			validateFifthRowSecondColumn:		
[1433]    1001: 83 F9 20                              			cmp cx, 32
[1434]    1004: 77 08                                 			ja validateFifthRowThirdColumn
[1435]    1006: BB 5D 00                              			lea bx, randomNumberSequence + 7
[1436]    1009: 8A 07                                 			mov al, [bx]		; number selector, third row mid cell, select eight index of randomNumberSequence
[1437]    100B: E9 B6 00                              			jmp numberIsValid
[1438]        :                                       			
[1439]    100E:                                       			validateFifthRowThirdColumn:
[1440]    100E: 83 F9 2E                              			cmp cx, 46
[1441]    1011: 77 08                                 			ja validateFifthRowForthColumn
[1442]    1013: BB 5E 00                              			lea bx, randomNumberSequence + 8
[1443]    1016: 8A 07                                 			mov al, [bx]		; number selector, third row right cell, select ninth index of randomNumberSequence
[1444]    1018: E9 A9 00                              			jmp numberIsValid
[1445]        :                                       			
[1446]        :                                       			
[1447]    101B:                                       			validateFifthRowForthColumn:
[1448]    101B: 83 F9 3C                              			cmp cx, 60
[1449]    101E: 77 1A                                 			ja validateFifthRowFifthColumn
[1450]    1020: 80 3E 55 00 00                        			cmp operation, 0
[1451]    1025: 74 03 E9 B4 00                        	   		jne inputIsFinished	; operation has already been set.	   	
[1452]    102A: C6 06 55 00 2B                        	   		mov operation, '+'
[1453]    102F: C6 06 17 08 FB                        	   		mov digitToPrint, '+' - 48	; print operator. proc used mainly for numbers (used with ascii 0 - 9)
[1454]    1034: E8 CF 00                              	   		call printInputDigit		   		
[1455]    1037: E9 A4 00                              	   		jmp inputIsFinished
[1456]        :                                       	   		
[1457]    103A:                                       			validateFifthRowFifthColumn:
[1458]    103A: 80 3E 55 00 00                        		        cmp operation, 0
[1459]    103F: 74 03 E9 9A 00                        	   		jne inputIsFinished	; operation has already been set.	   	
[1460]    1044: C6 06 55 00 2D                        	   		mov operation, '-'	
[1461]    1049: C6 06 17 08 FD                        	   		mov digitToPrint, '-' - 48	; print operator. proc used mainly for numbers (used with ascii 0 - 9)
[1462]    104E: E8 B5 00                              	   		call printInputDigit	
[1463]    1051: E9 8A 00                              	   		jmp inputIsFinished
[1464]        :                                       			
[1465]    1054:                                       		validateSixthRow:
[1466]    1054: 83 F9 12                              			cmp cx, 18
[1467]    1057: 77 07                                 			ja validateSixthRowSecondColumn
[1468]    1059: BB 5F 00                              			lea bx, randomNumberSequence + 9
[1469]    105C: 8A 07                                 			mov al, [bx]		; number selector, forth row left cell, select tenth (last) index of randomNumberSequence
[1470]    105E: EB 64                                 			jmp numberIsValid
[1471]        :                                       			
[1472]    1060:                                       			validateSixthRowSecondColumn:		
[1473]    1060: 83 F9 20                              			cmp cx, 32
[1474]    1063: 77 03                                 			ja validateSixthRowThirdColumn
[1475]        :                                       			; decimal dot not yet implemented
[1476]    1065: E9 3E FE                              			jmp readingDigit
[1477]        :                                       			
[1478]    1068:                                       			validateSixthRowThirdColumn:
[1479]    1068: 83 F9 2E                              			cmp cx, 46
[1480]    106B: 77 03                                 			ja validateSixthRowForthColumn
[1481]        :                                       			; negative sign not yet implemented
[1482]    106D: E9 21 04                              			jmp exitProgram
[1483]        :                                       			
[1484]    1070:                                       			validateSixthRowForthColumn:
[1485]    1070: 83 F9 3C                              			cmp cx, 60
[1486]    1073: 77 16                                 			ja validateSixthRowFifthColumn
[1487]    1075: 80 3E 55 00 00                        			cmp operation, 0
[1488]    107A: 75 62                                 	   		jne inputIsFinished	; operation has already been set.	   		
[1489]    107C: C6 06 55 00 2A                        	   		mov operation, '*'
[1490]    1081: C6 06 17 08 FA                        	   		mov digitToPrint, '*' - 48	; print operator. proc used mainly for numbers (used with ascii 0 - 9)
[1491]    1086: E8 7D 00                              	   		call printInputDigit	
[1492]    1089: EB 53                                 	   		jmp inputIsFinished
[1493]        :                                       	   		
[1494]    108B:                                       			validateSixthRowFifthColumn:
[1495]    108B: 80 3E 55 00 00                        		        cmp operation, 0
[1496]    1090: 75 4C                                 	   		jne inputIsFinished	; operation has already been set.	   	
[1497]    1092: C6 06 55 00 2F                        	   		mov operation, '/'	   		
[1498]    1097: C6 06 17 08 FF                        	   		mov digitToPrint, '/' - 48	; print operator. proc used mainly for numbers (used with ascii 0 - 9)
[1499]    109C: E8 67 00                              	   		call printInputDigit	
[1500]    109F: EB 3D                                 	   		jmp inputIsFinished
[1501]        :                                       	   		 	        	   						
[1502]        :                                       	   	
[1503]    10A1:                                       		isBackspace:	  		
[1504]        :                                       			; validate edge case if no number has been inputed yet, If so, don't delete, return to reading cycle
[1505]    10A1: B9 09 00                              	   		mov cx, length			
[1506]    10A4: 39 0E 37 00                           	   		cmp inputLoopCounter, cx
[1507]    10A8: 75 03 E9 F9 FD                        	  		je readingDigit     			
[1508]        :                                       			
[1509]    10AD: E8 09 01                              			call deleteLastCharacter
[1510]        :                                       			
[1511]    10B0: 58                                    			pop ax	; remove the digit from the stack	  		      	  	
[1512]        :                                       	  		
[1513]    10B1: FF 06 37 00                           	  		inc inputLoopCounter	; allow for another loop iteration
[1514]        :                                       	  		 	
[1515]    10B5: E9 EE FD                              	   		jmp readingDigit	   		   	 	   	                                   	   			   			   		
[1516]        :                                       	
[1517]    10B8:                                       	        numberIsOfmaxSize:
[1518]        :                                       	 		; since the number is max size no more digits can be added to it. Only a operator
[1519]    10B8: E8 FE 00                              			call deleteLastCharacter
[1520]    10BB: E9 E8 FD                              	 		jmp readingDigit
[1521]        :                                       	 		
[1522]    10BE:                                       	 	deletePrev:
[1523]        :                                       	 		; since the number is max size no more digits can be added to it. Only a operator
[1524]    10BE: E8 F8 00                              			call deleteLastCharacter
[1525]    10C1: E9 E2 FD                              	 		jmp readingDigit
[1526]        :                                       	
[1527]    10C4:                                       	        numberIsValid:
[1528]        :                                       			; validate amount number of digits remaining	        		        	
[1529]    10C4: 8B 0E 37 00                           	        	mov cx, inputLoopCounter
[1530]    10C8: 83 F9 00                              	        	cmp cx, 0	
[1531]    10CB: 75 03 E9 D6 FD                        	        	je readingDigit	; if limit reached, don't add process input and go back to the read cycle
[1532]        :                                       	        	
[1533]        :                                       	        	; todo validate divisor. Must not be zero.  You can use the arrayIsZero procedure after the input has been completed 	        	
[1534]        :                                       	        	
[1535]        :                                       	        	; digits will be pushed into the stack on their correct order of magnitude
[1536]        :                                       	        	; they will later on, the popped out and inserted right to left (least significative to most significative)
[1537]        :                                       	        	; doing this to avoid this routine rightShiftUntilTheUnitDigitOfTheInputIsInTheCorrespondingUnitPositionInTheNumberArray:
[1538]    10D0: 50                                    	        	push ax			; push digit into stack
[1539]    10D1: FF 0E 37 00                           	        	dec inputLoopCounter
[1540]        :                                       	        	
[1541]    10D5: A2 17 08                              	        	mov digitToPrint, al
[1542]    10D8: E8 2B 00                              	        	call printInputDigit
[1543]        :                                       	        	
[1544]    10DB: E9 C8 FD                              	   		jmp readingDigit	; ask for the next digit
[1545]        :                                       	   			   	
[1546]    10DE:                                       		inputIsFinished:
[1547]    10DE: B9 09 00                              		mov cx, length
[1548]    10E1: 39 0E 37 00                           		cmp inputLoopCounter, cx	; user didn't insert a number; assume number 0 (at start of input array contains only zeros)
[1549]    10E5: 74 12                                 		je skipStackPop
[1550]        :                                       	
[1551]    10E7:                                       	popIntoNumberArray:	
[1552]        :                                       	
[1553]        :                                       	; mov si pointer into the last index of the array
[1554]    10E7: 83 C6 08                              	add si, length - 1	; move to the end of the number
[1555]        :                                       	
[1556]        :                                       	; calculate the number of digits inserted
[1557]    10EA: B8 09 00                              	mov ax, length			; start with max amount of digits
[1558]    10ED: 2B 06 37 00                           	sub ax, inputLoopCounter	; subtract number of digits left unsused (remaining value in cx is the number of iterations left when the loop to read digits was cut short)
[1559]    10F1: 8B C8                                 	mov cx, ax			; set amount of iterations for the 'popIntoDigitIntoArray' procedure
[1560]        :                                       	
[1561]    10F3:                                       	popIntoDigitIntoArray:	; pop the digits of the number into the array                     	
[1562]    10F3: 58                                    		pop ax		; pop digit		
[1563]    10F4: 88 04                                 		mov [si], al    ; move digit into corresponding array position
[1564]    10F6: 4E                                    		dec si          ; decrease array index
[1565]    10F7: E2 FA                                 	        loop popIntoDigitIntoArray	; complete iterations to pop the remainding digits of the number into the array	
[1566]        :                                       	
[1567]    10F9:                                       	skipStackPop:
[1568]        :                                       					 			
[1569]    10F9: B8 00 00                              	mov ax, 0
[1570]    10FC: BA 00 00                              	mov dx, 0
[1571]    10FF: BE 00 00                              	mov si, 0
[1572]    1102: BF 00 00                              	mov di, 0
[1573]        :                                       			
[1574]    1105: C3                                    	ret
[1575]        :                                       readNumberInput ENDP
[1576]        :                                       
[1577]        :                                       
[1578]        :                                       
[1579]    1106:                                       printInputDigit proc
[1580]        :                                       	
[1581]        :                                       	; outputs a digit to the input text area
[1582]        :                                       	
[1583]        :                                       	; input: ascii code of digit to print is specified in digitToPrint varaible.
[1584]        :                                       	
[1585]        :                                       	;mov ax, 0xB800		; point ax to the start of video memory (0xB800:0000)
[1586]        :                                       	;mov es, ax
[1587]    1106: 33 FF                                 	xor di, di		; di used to iterate through video memory
[1588]        :                                       	
[1589]        :                                       	; calculte input cell offset
[1590]    1108: B8 50 00                              	mov ax, 80			; row length
[1591]    110B: 8B 16 13 08                           	mov dx, inputAreaCurrentRow	; number of rows to offset
[1592]    110F: F7 E2                                 	mul dx				; calculate row offset
[1593]        :                                       	
[1594]    1111: 8B 1E 15 08                           	mov bx, inputAreaCurrentColumn	
[1595]    1115: 83 C3 04                              	add bx, 4                       ; left offset
[1596]    1118: 03 C3                                 	add ax, bx			; calculate column
[1597]    111A: BA 02 00                              	mov dx, 2			; each cell is composed of 2 bytes (one for char and next one for attribute)
[1598]        :                                       	
[1599]    111D: F7 E2                                 	mul dx	    			; mul by 2
[1600]    111F: 8B F8                                 	mov di, ax			; di used as offset in video memory	
[1601]    1121: A0 17 08                              	mov al, digitToPrint
[1602]        :                                       	
[1603]    1124: 04 30                                 	add al, 48
[1604]        :                                       	
[1605]    1126: 26 88 05                              	mov byte ptr es:[di], al	; write character
[1606]    1129: 26 C6 45 01 40                        	mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1607]        :                                       	
[1608]    112E: FF 06 15 08                           	inc inputAreaCurrentColumn
[1609]        :                                       	
[1610]    1132: C3                                    	ret
[1611]        :                                       printInputDigit endp
[1612]        :                                       
[1613]        :                                       
[1614]        :                                       
[1615]    1133:                                       printOutput proc                                                          			
[1616]        :                                       	
[1617]        :                                       	; printOutput proc -> renders the result in the output text area
[1618]        :                                       
[1619]    1133: 33 FF                                 	xor di, di	; di used to iterate through video memory
[1620]        :                                       	
[1621]        :                                       	; calculte input cell offset
[1622]    1135: B8 50 00                              	mov ax, 80	; row length
[1623]    1138: BA 06 00                              	mov dx, 6	; number of rows to offset
[1624]    113B: F7 E2                                 	mul dx		; calculate row offset
[1625]        :                                       	
[1626]    113D: BB 02 00                              	mov bx, 2	
[1627]    1140: 83 C3 04                              	add bx, 4	; left offset
[1628]    1143: 03 C3                                 	add ax, bx	; calculate column offset
[1629]    1145: BA 02 00                              	mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[1630]    1148: F7 E2                                 	mul dx		; mul by 2 (each console character is composed of 2 bytes: character + attribute)
[1631]        :                                       	
[1632]        :                                       	; offset has been calculated, now move di to the correct position
[1633]        :                                       	
[1634]    114A: 8B F8                                 	mov di, ax	; offset di to the start cell of the output text area			
[1635]        :                                       	
[1636]        :                                       	; determine which type of output we're facing: number or text
[1637]    114C: 80 3E 0C 00 01                        	cmp textOutput, 1	; 0: number , 1: text
[1638]    1151: 74 4C                                 	je printTextOutput	; if text output, go to the text output code
[1639]        :                                       	
[1640]        :                                       	; The output procedure validates for leading zeros and if it's a leading zero, it does not print it
[1641]        :                                       	; The issue is, if no validation is preformed, for the number zero, nothing will be printed
[1642]        :                                       	; this because the the leading zero validation uses any number different to zero
[1643]        :                                       	; since zero does not contain any non-zero number, every digit of the array will be considered a leading zero and nothing will get printed
[1644]        :                                       	; To fix this issue, the print loop will not print the last digit (meaning it will not reform the leading zero on the last digit)
[1645]        :                                       	; then we will manually print the last digit (without validating for a leading zero).
[1646]        :                                       	; Like this, we assure when printing number 0 that a leading zero bug does not occour.
[1647]        :                                       	
[1648]    1153: B9 08 00                              	mov cx, length 	- 1	; loop over every digit minus the least significant digit
[1649]    1156: BE 00 00                              	lea si, result  	; point into the beggining result array	
[1650]        :                                       	
[1651]    1159:                                       	outputSignValidation:
[1652]    1159: 80 3E 09 00 01                        	cmp resultSign, 1	; (0 = positive number, 1 = negative number)
[1653]    115E: 75 0A                                 	jne outputDigit
[1654]        :                                       	
[1655]        :                                       	; negative result, output a negative sign first
[1656]        :                                       	
[1657]    1160: 26 C6 05 2D                           	mov byte ptr es:[di], 45	; '-' minus character
[1658]    1164: 26 C6 45 01 40                        	mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1659]    1169: 47                                    	inc di
[1660]        :                                       	
[1661]    116A:                                       	outputDigit:
[1662]        :                                       		; process each digit on each iteration
[1663]        :                                       		; validate for leading zero and print if it isn't a leading zero
[1664]        :                                       		; todo the next line is moving a value into dh. why? si shouldn't point to a dw var? I can't be bothered to check right now. Future you, do that
[1665]    116A: 8B 14                                 	    	mov dx, [si]	; Move digit from result into dx for processing
[1666]    116C: 80 FA 00                              		cmp dl, 0	; Compare the digit with zero
[1667]    116F: 74 05                                 		je checkZero	; If zero, check if it can be ignored as a leading zero
[1668]        :                                       	    	
[1669]    1171: BB 01 00                              		mov bx, 1	; Found a non-zero digit, enable leading zero flag
[1670]    1174: EB 05                                 		jmp printDigit	; Jump to printing the digit
[1671]        :                                       	
[1672]    1176:                                       	checkZero:
[1673]    1176: 83 FB 01                              	    	cmp bx, 1	; Check if the leading zero flag is enabled
[1674]    1179: 75 0F                                 	    	jne skipDigit	; If not enabled, skip this zero
[1675]        :                                       	
[1676]    117B:                                       	printDigit:
[1677]    117B: 8A 04                                 	    	mov al, [si]	
[1678]    117D: 04 30                                 		add al, 48	
[1679]    117F: 26 88 05                              		mov byte ptr es:[di], al	; write character
[1680]    1182: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1681]    1187: 83 C7 02                              	 	add di, 2			; offset di by 2, needs also to skip the current cell attribute byte
[1682]        :                                       	 	
[1683]    118A:                                       	skipDigit:
[1684]    118A: 46                                    	    	inc si		; Move to the next digit
[1685]    118B: E2 DD                                 	    	loop outputDigit; Repeat for the next digit
[1686]        :                                       	
[1687]        :                                       	; manually print the last digit
[1688]    118D: 8A 14                                 	mov dl, [si]    	
[1689]    118F: 80 C2 30                              	add dl, 48	; Convert number into ASCII character
[1690]        :                                       	
[1691]    1192: 26 88 15                              	mov byte ptr es:[di], dl	; write character
[1692]    1195: 26 C6 45 01 40                        	mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1693]    119A: 83 C7 02                              	add di, 2			; offset di by 2, needs also to skip the current cell attribute byte
[1694]        :                                       	
[1695]    119D: EB 19                                 	jmp printOutputFinished
[1696]        :                                       	
[1697]    119F:                                       	printTextOutput:
[1698]        :                                       	
[1699]    119F: 8B 36 0D 00                           	        mov si, textToOutputMemoryAddress
[1700]        :                                       	
[1701]    11A3:                                       	        printDigitFromTextOutput:
[1702]        :                                       	
[1703]    11A3: 80 3C 24                              			cmp [si], '$'
[1704]    11A6: 74 10                                 			je printOutputFinished
[1705]    11A8: 8A 04                                 	                mov al, [si]
[1706]    11AA: 26 88 05                              			mov byte ptr es:[di], al	; write character
[1707]    11AD: 26 C6 45 01 40                        			mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1708]        :                                       	  		
[1709]    11B2: 83 C7 02                              	  		add di, 2
[1710]    11B5: 46                                    	  		inc si
[1711]        :                                       	  		
[1712]    11B6: EB EB                                 	  		jmp printDigitFromTextOutput
[1713]        :                                       	  		
[1714]    11B8:                                       	printOutputFinished:	  		
[1715]        :                                       	
[1716]    11B8: C3                                    	ret
[1717]        :                                       printOutput endp
[1718]        :                                       
[1719]        :                                       
[1720]    11B9:                                       deleteLastCharacter proc
[1721]        :                                       	
[1722]    11B9: FF 0E 15 08                           	dec inputAreaCurrentColumn
[1723]        :                                       	
[1724]    11BD: 33 FF                                 	xor di, di		; di used to iterate through video memory
[1725]        :                                       	
[1726]        :                                       	; calculte input cell offset
[1727]    11BF: B8 50 00                              	mov ax, 80			; row length
[1728]    11C2: 8B 16 13 08                           	mov dx, inputAreaCurrentRow	; number of rows to offset
[1729]    11C6: F7 E2                                 	mul dx				; calculate row offset
[1730]        :                                       	
[1731]    11C8: 8B 1E 15 08                           	mov bx, inputAreaCurrentColumn	
[1732]    11CC: 83 C3 04                              	add bx, 4                       ; left offset
[1733]    11CF: 03 C3                                 	add ax, bx			; calculate column offset
[1734]    11D1: BA 02 00                              	mov dx, 2			; each cell is composed of 2 bytes (one for char and next one for attribute)
[1735]    11D4: F7 E2                                 	mul dx	    			; mul by 2
[1736]    11D6: 8B F8                                 	mov di, ax			; di used as offset in video memory
[1737]        :                                       	
[1738]        :                                       	
[1739]    11D8: 26 C6 05 20                           	mov byte ptr es:[di], ' '	; write character
[1740]    11DC: 26 C6 45 01 40                        	mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, red foreground	
[1741]        :                                       	
[1742]    11E1: C3                                    	ret
[1743]        :                                       deleteLastCharacter endp
[1744]        :                                       
[1745]        :                                       
[1746]    11E2:                                       config proc
[1747]        :                                       	; config data segment
[1748]    11E2: B8 10 00                              	mov ax, @data	; load data segment
[1749]    11E5: 8E D8                                 	mov ds, ax      ; load data segment
[1750]        :                                       	
[1751]        :                                       	; config extra segment for video memory
[1752]    11E7: B8 00 B8                              	mov ax, 0xB800	; load video memory start address
[1753]    11EA: 8E C0                                 	mov es, ax	; load extra segment with video memory
[1754]        :                                       	
[1755]        :                                       	; set text video mode
[1756]    11EC: B8 03 00                              	mov ax, 03h	; set video mode configuration 3
[1757]    11EF: CD 10                                 	int 10h	
[1758]        :                                       	
[1759]        :                                       	; reset mouse cursor
[1760]    11F1: B8 00 00                              	mov ax, 0000h	; reset mouse
[1761]    11F4: CD 33                                 	int 33h                                                                                                                                                                               	
[1762]        :                                       			
[1763]    11F6: C3                                    	ret
[1764]        :                                       config endp
[1765]        :                                       
[1766]        :                                       
[1767]        :                                       
[1768]    11F7:                                       generateRandomNumberSequence proc
[1769]        :                                       
[1770]    11F7: BF 00 00                              mov di, 0	; keep track of how many digits have been inserted / how many are yet to insert
[1771]    11FA:                                       requestDigit:
[1772]        :                                       
[1773]        :                                       		; int 1ah / 0h
[1774]        :                                       		; returns the current time
[1775]        :                                       		; dl contains the hundredths of a second (0 - 99)
[1776]        :                                       		; get the units digit, since it's the
[1777]    11FA: B4 00                                 mov ah, 0
[1778]    11FC: CD 1A                                 		int 1ah		; get current time
[1779]        :                                       		
[1780]    11FE: B4 00                                 		mov ah, 0	; set higher portion of ax to 0.
[1781]    1200: 8A C2                                 		mov al, dl	; move hundredths to ax to then mod 10
[1782]    1202: B2 0A                                 		mov dl, 10	; reset dx para zero
[1783]    1204: F6 F2                                 	div dl
[1784]        :                                       	
[1785]        :                                       	; remainder in ah		
[1786]        :                                       	
[1787]        :                                       	; each number can only occur once
[1788]        :                                       	; validate if the randomNumberSequence already contains the generated number
[1789]    1206: B9 0A 00                              	mov cx, 10        	
[1790]    1209:                                       	validateIfRandomNumberSequenceAlreadyContainsGeneratedDigit:
[1791]    1209: BE 56 00                              		lea si, randomNumberSequence
[1792]    120C: 8B D9                                 		mov bx, cx
[1793]    120E: 83 EB 01                              		sub bx, 1		
[1794]    1211: 03 F3                                 			add si, bx	; point si to existing number
[1795]        :                                       	
[1796]    1213: 38 24                                 			cmp [si], ah
[1797]    1215: 74 E3                                 	  	je requestDigit        	  	            	 	
[1798]        :                                       	 	
[1799]    1217: E2 F0                                 		loop validateIfRandomNumberSequenceAlreadyContainsGeneratedDigit:
[1800]        :                                       	
[1801]        :                                       	; add unique digit to array
[1802]    1219:                                       	addUniqueDigitToRandomNumberSequenceArray:
[1803]        :                                       	      		
[1804]    1219: BE 56 00                              		lea si, randomNumberSequence
[1805]    121C: 03 F7                                 		add si, di
[1806]    121E: 88 24                                 		mov byte ptr [si], ah
[1807]    1220: 47                                    	inc di		; point di to the next position
[1808]        :                                       	
[1809]    1221: 83 FF 0A                              	cmp di,10
[1810]    1224: 72 D4                                 	jb requestDigit
[1811]        :                                       
[1812]    1226:                                       sequenceFinished:
[1813]        :                                       
[1814]    1226: C3                                    	ret
[1815]        :                                       generateRandomNumberSequence endp
[1816]        :                                       
[1817]        :                                       
[1818]        :                                       
[1819]    1227:                                       renderUI proc
[1820]        :                                       	; ---------------- background ---------------------
[1821]        :                                       	
[1822]        :                                       	
[1823]        :                                       	; ---------------- Calculator UI ---------------------
[1824]    1227: 33 FF                                 	xor di, di		; di used to iterate through video memory
[1825]        :                                       	
[1826]    1229: BE EF 00                              	lea si, calculatorUI	; point to the start of the string
[1827]        :                                       	
[1828]    122C: C7 06 0F 08 00 00                     	mov renderTableCurrentRow, 0
[1829]    1232: C7 06 11 08 04 00                     	mov renderTableCurrentColumn, 4	; start on column 4
[1830]        :                                       
[1831]    1238:                                       	writeSymbolToVideoMemory:
[1832]        :                                       				
[1833]        :                                       		; update current row and column guide variables
[1834]    1238: A1 0F 08                              		mov ax, [renderTableCurrentRow]
[1835]    123B: BB 50 00                              		mov bx, 80
[1836]    123E: F7 E3                                 		mul bx            ; ax = curRow * 80
[1837]    1240: 03 06 11 08                           		add ax, [renderTableCurrentColumn]  ; ax = row*80 + col
[1838]    1244: D1 E0                                 		shl ax, 1         ; *2 for text mode offset
[1839]    1246: 8B F8                                 		mov di, ax
[1840]        :                                       		
[1841]        :                                       		; process character						
[1842]    1248: 8A 04                                 		mov al, [si]		; load current character
[1843]    124A: 3C 24                                 		cmp al, '$'		; check for end of string
[1844]    124C: 74 3D                                 		je renderRandomNumberSequence			
[1845]    124E: 3C 0D                                 		cmp al, 13		; carriage return	ascii 10
[1846]    1250: 74 30                                 		je handleCarriageReturn
[1847]    1252: 3C 0A                                 		cmp al, 10		; line feed 		ascii 13
[1848]    1254: 74 22                                 		je handleLineFeed
[1849]    1256: 3C B9                                 		cmp al, 185		; border, validate upper and lower range (sqrt symbol is 252, therefore need to validate upper range)
[1850]    1258: 72 04                                 		jb setCharacterStyle		
[1851]    125A: 3C CE                                 		cmp al, 206
[1852]    125C: 76 04                                 		jbe setBorderStyle
[1853]        :                                       		
[1854]    125E:                                       		setCharacterStyle:						
[1855]    125E: B4 40                                 		mov ah, 0x40		; attribute byte defined as red background, black foreground	
[1856]    1260: EB 02                                 		jmp printCharacter
[1857]        :                                       		
[1858]    1262:                                       		setBorderStyle:
[1859]    1262: B4 47                                 		mov ah, 0x47		; attribute byte defined as red background, light grey foreground					
[1860]        :                                       		
[1861]    1264:                                       		printCharacter:
[1862]        :                                       		; write character & attribute directly intto video memory
[1863]    1264: 26 88 05                              		mov byte ptr es:[di], al	; write character
[1864]    1267: 26 88 65 01                           		mov byte ptr es:[di+1], ah	; write attribute
[1865]        :                                       
[1866]    126B:                                       		characterPrinted:
[1867]    126B: 83 C7 02                              		add di, 2		; move into next cell in video memory
[1868]    126E: 46                                    		inc si			; move to next character in string
[1869]        :                                       		
[1870]        :                                       		; increment col
[1871]    126F: A1 11 08                              		mov ax, [renderTableCurrentColumn]
[1872]    1272: 40                                    		inc ax
[1873]    1273: A3 11 08                              		mov [renderTableCurrentColumn], ax
[1874]        :                                       		
[1875]    1276: EB C0                                 		jmp writeSymbolToVideoMemory
[1876]        :                                       		
[1877]    1278:                                       		handleLineFeed:
[1878]        :                                       		    ; lf -> go to row bellow
[1879]    1278: A1 0F 08                              		    mov ax, [renderTableCurrentRow]
[1880]    127B: 40                                    		    inc ax
[1881]    127C: A3 0F 08                              		    mov [renderTableCurrentRow], ax
[1882]    127F: 46                                    		    inc si
[1883]    1280: EB B6                                 		    jmp writeSymbolToVideoMemory
[1884]        :                                       		
[1885]    1282:                                       		handleCarriageReturn:
[1886]        :                                       		    ; cr -> go to benninging of the row
[1887]    1282: C7 06 11 08 04 00                     		    mov word ptr [renderTableCurrentColumn], 4
[1888]    1288: 46                                    		    inc si
[1889]    1289: EB AD                                 		    jmp writeSymbolToVideoMemory
[1890]        :                                       
[1891]    128B:                                       		renderRandomNumberSequence:
[1892]        :                                       		
[1893]        :                                       		; It remains to insert the numbers in the calculator
[1894]        :                                       		; the number sequence has been generated in procedure generateRandomNumberSequence
[1895]        :                                       		; and stored into the randomNumberSequence array
[1896]        :                                       		; Each cell has a static position in the video memory		
[1897]        :                                       		; for the video mode used (10h / 03h -> 80x25), the position of each cell is:
[1898]        :                                       		; first row	left cell	80 * 10 + 7
[1899]        :                                       		; first row	mid cell	80 * 10 + 21
[1900]        :                                       		; first row	right cell	80 * 10 + 35
[1901]        :                                       		; second row	left cell	80 * 14 + 7
[1902]        :                                       		; second row	mid cell	80 * 14 + 21
[1903]        :                                       		; second row	right cell	80 * 14 + 35
[1904]        :                                       		; third row	left cell	80 * 18 + 7
[1905]        :                                       		; third row	mid cell	80 * 18 + 21
[1906]        :                                       		; third row	right cell	80 * 18 + 35
[1907]        :                                       		; fourth row	left cell	80 * 22 + 7
[1908]        :                                       		
[1909]        :                                       		; "ษออออออออออออออออออออนSmart Logic Based calculatorฬอออออออออออออออออออป",13,10,
[1910]        :                                       		; "บ                                                                     บ",13,10,
[1911]        :                                       		; "บ                                                                     บ",13,10,
[1912]        :                                       		; "บ                                                                     บ",13,10,
[1913]        :                                       		; "ฬอออออออออออออออออออออออออออออออออออออออออหอออออออออออออหอออออออออออออน",13,10,
[1914]        :                                       		; "บ                                         บ             บ             บ",13,10,
[1915]        :                                       		; "บ                                         บ      =      บ     DEL     บ",13,10,
[1916]        :                                       		; "บ                                         บ             บ             บ",13,10,
[1917]        :                                       		; "ฬอออออออออออออหอออออออออออออหอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
[1918]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1919]        :                                       		; "บ 80 * 10 + 7 บ 80 * 10 + 21บ 80 * 10 + 35บ    EAN13    บ     NIF     บ",13,10,
[1920]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1921]        :                                       		; "ฬอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
[1922]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1923]        :                                       		; "บ 80 * 14 + 7 บ 80 * 14 + 21บ 80 * 14 + 35บ     ๛      บ     C C     บ",13,10,
[1924]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1925]        :                                       		; "ฬอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
[1926]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1927]        :                                       		; "บ 80 * 18 + 7 บ 80 * 18 + 21บ 80 * 18 + 35บ      +      บ      -      บ",13,10,
[1928]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1929]        :                                       		; "ฬอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออฮอออออออออออออน",13,10,
[1930]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1931]        :                                       		; "บ 80 * 22 + 7 บ      .      บ     END     บ      *      บ      /      บ",13,10,
[1932]        :                                       		; "บ             บ             บ             บ             บ             บ",13,10,
[1933]        :                                       		; "ศอออออออออออออสอออออออออออออสอออออออออออออสอออออออออออออสอออออออออออออผ$"
[1934]        :                                       
[1935]    128B: 33 FF                                 		xor di, di		; di used to iterate through video memory
[1936]    128D: B9 00 00                              		mov cx, 0		; cx used to iterate over the randomNumberSequence array		
[1937]        :                                       	
[1938]        :                                       		
[1939]        :                                       		
[1940]        :                                       		; -------------------- first row left cell ------------------------ 		
[1941]        :                                       		; calculte first row left cell offset
[1942]    1290: B8 50 00                              		mov ax, 80	; row length
[1943]    1293: BA 0A 00                              		mov dx, 10	; number of rows
[1944]    1296: F7 E2                                 		mul dx		; calculate row offset
[1945]    1298: 05 0B 00                              		add ax, 4 + 7	; calculate column
[1946]    129B: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[1947]    129E: F7 E2                                 		mul dx	    	; mul by 2
[1948]    12A0: 8B F8                                 		mov di, ax	; di used as offset in video memory
[1949]        :                                       		
[1950]        :                                       		; get first row left cell number (first element of randomNumberSequence)
[1951]    12A2: BE 56 00                              		lea si, randomNumberSequence
[1952]    12A5: 03 F1                                 		add si, cx
[1953]    12A7: 41                                    		inc cx
[1954]    12A8: 8A 04                                 		mov al, [si]	; copy value from array into al
[1955]    12AA: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[1956]        :                                       		
[1957]        :                                       		; write to video memory		
[1958]    12AC: 26 88 05                              		mov byte ptr es:[di], al	; write character
[1959]    12AF: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1960]        :                                       	
[1961]        :                                       		
[1962]        :                                       		
[1963]        :                                       		; -------------------- first row mid cell ------------------------ 		
[1964]        :                                       		; calculte first row mid cell offset
[1965]    12B4: B8 50 00                              		mov ax, 80	; row length
[1966]    12B7: BA 0A 00                              		mov dx, 10	; number of rows
[1967]    12BA: F7 E2                                 		mul dx		; calculate row offset
[1968]    12BC: 05 19 00                              		add ax, 4 + 21	; calculate column
[1969]    12BF: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[1970]    12C2: F7 E2                                 		mul dx	    	; mul by 2
[1971]    12C4: 8B F8                                 		mov di, ax	; di used as offset in video memory
[1972]        :                                       		
[1973]        :                                       		; get first row mid cell number (second element of randomNumberSequence)
[1974]    12C6: BE 56 00                              		lea si, randomNumberSequence
[1975]    12C9: 03 F1                                 		add si, cx
[1976]    12CB: 41                                    		inc cx
[1977]    12CC: 8A 04                                 		mov al, [si]	; copy value from array into al
[1978]    12CE: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[1979]        :                                       		
[1980]        :                                       		; write to video memory		
[1981]    12D0: 26 88 05                              		mov byte ptr es:[di], al	; write character
[1982]    12D3: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[1983]        :                                       		
[1984]        :                                       		
[1985]        :                                       		
[1986]        :                                       		; -------------------- first row right cell ------------------------ 		
[1987]        :                                       		; calculte first row right cell offset
[1988]    12D8: B8 50 00                              		mov ax, 80	; row length
[1989]    12DB: BA 0A 00                              		mov dx, 10	; number of rows
[1990]    12DE: F7 E2                                 		mul dx		; calculate row offset
[1991]    12E0: 05 27 00                              		add ax, 4 + 35	; calculate column
[1992]    12E3: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[1993]    12E6: F7 E2                                 		mul dx	    	; mul by 2
[1994]    12E8: 8B F8                                 		mov di, ax	; di used as offset in video memory
[1995]        :                                       		
[1996]        :                                       		; get first row right cell number (third element of randomNumberSequence)
[1997]    12EA: BE 56 00                              		lea si, randomNumberSequence
[1998]    12ED: 03 F1                                 		add si, cx
[1999]    12EF: 41                                    		inc cx
[2000]    12F0: 8A 04                                 		mov al, [si]	; copy value from array into al
[2001]    12F2: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2002]        :                                       		
[2003]        :                                       		; write to video memory		
[2004]    12F4: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2005]    12F7: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2006]        :                                       		
[2007]        :                                       		
[2008]        :                                       		
[2009]        :                                       		; -------------------- second row left cell ------------------------ 		
[2010]        :                                       		; calculte second row left cell offset
[2011]    12FC: B8 50 00                              		mov ax, 80	; row length
[2012]    12FF: BA 0E 00                              		mov dx, 14	; number of rows
[2013]    1302: F7 E2                                 		mul dx		; calculate row offset
[2014]    1304: 05 0B 00                              		add ax, 4 + 7	; calculate column
[2015]    1307: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2016]    130A: F7 E2                                 		mul dx	    	; mul by 2
[2017]    130C: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2018]        :                                       		
[2019]        :                                       		; get second row left cell number (forth element of randomNumberSequence)
[2020]    130E: BE 56 00                              		lea si, randomNumberSequence
[2021]    1311: 03 F1                                 		add si, cx
[2022]    1313: 41                                    		inc cx
[2023]    1314: 8A 04                                 		mov al, [si]	; copy value from array into al
[2024]    1316: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2025]        :                                       		
[2026]        :                                       		; write to video memory		
[2027]    1318: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2028]    131B: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2029]        :                                       	
[2030]        :                                       		
[2031]        :                                       		
[2032]        :                                       		; -------------------- second row mid cell ------------------------ 		
[2033]        :                                       		; calculte second row mid cell offset
[2034]    1320: B8 50 00                              		mov ax, 80	; row length
[2035]    1323: BA 0E 00                              		mov dx, 14	; number of rows
[2036]    1326: F7 E2                                 		mul dx		; calculate row offset
[2037]    1328: 05 19 00                              		add ax, 4 + 21	; calculate column
[2038]    132B: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2039]    132E: F7 E2                                 		mul dx	    	; mul by 2
[2040]    1330: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2041]        :                                       		
[2042]        :                                       		; get second row mid cell number (fifth element of randomNumberSequence)
[2043]    1332: BE 56 00                              		lea si, randomNumberSequence
[2044]    1335: 03 F1                                 		add si, cx
[2045]    1337: 41                                    		inc cx
[2046]    1338: 8A 04                                 		mov al, [si]	; copy value from array into al
[2047]    133A: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2048]        :                                       		
[2049]        :                                       		; write to video memory		
[2050]    133C: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2051]    133F: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2052]        :                                       		
[2053]        :                                       		
[2054]        :                                       		
[2055]        :                                       		; -------------------- second row right cell ------------------------ 		
[2056]        :                                       		; calculte second row right cell offset
[2057]    1344: B8 50 00                              		mov ax, 80	; row length
[2058]    1347: BA 0E 00                              		mov dx, 14	; number of rows
[2059]    134A: F7 E2                                 		mul dx		; calculate row offset
[2060]    134C: 05 27 00                              		add ax, 4 + 35	; calculate column
[2061]    134F: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2062]    1352: F7 E2                                 		mul dx	    	; mul by 2
[2063]    1354: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2064]        :                                       		
[2065]        :                                       		; get second row right cell number (sixth element of randomNumberSequence)
[2066]    1356: BE 56 00                              		lea si, randomNumberSequence
[2067]    1359: 03 F1                                 		add si, cx
[2068]    135B: 41                                    		inc cx
[2069]    135C: 8A 04                                 		mov al, [si]	; copy value from array into al
[2070]    135E: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2071]        :                                       		
[2072]        :                                       		; write to video memory		
[2073]    1360: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2074]    1363: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2075]        :                                       		
[2076]        :                                       		
[2077]        :                                       		
[2078]        :                                       		; -------------------- third row left cell ------------------------ 		
[2079]        :                                       		; calculte third row left cell offset
[2080]    1368: B8 50 00                              		mov ax, 80	; row length
[2081]    136B: BA 12 00                              		mov dx, 18	; number of rows
[2082]    136E: F7 E2                                 		mul dx		; calculate row offset
[2083]    1370: 05 0B 00                              		add ax, 4 + 7	; calculate column
[2084]    1373: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2085]    1376: F7 E2                                 		mul dx	    	; mul by 2
[2086]    1378: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2087]        :                                       		
[2088]        :                                       		; get third row left cell number (seventh element of randomNumberSequence)
[2089]    137A: BE 56 00                              		lea si, randomNumberSequence
[2090]    137D: 03 F1                                 		add si, cx
[2091]    137F: 41                                    		inc cx
[2092]    1380: 8A 04                                 		mov al, [si]	; copy value from array into al
[2093]    1382: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2094]        :                                       		
[2095]        :                                       		; write to video memory		
[2096]    1384: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2097]    1387: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2098]        :                                       	
[2099]        :                                       		
[2100]        :                                       		
[2101]        :                                       		; -------------------- third row mid cell ------------------------ 		
[2102]        :                                       		; calculte third row mid cell offset
[2103]    138C: B8 50 00                              		mov ax, 80	; row length
[2104]    138F: BA 12 00                              		mov dx, 18	; number of rows
[2105]    1392: F7 E2                                 		mul dx		; calculate row offset
[2106]    1394: 05 19 00                              		add ax, 4 + 21	; calculate column
[2107]    1397: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2108]    139A: F7 E2                                 		mul dx	    	; mul by 2
[2109]    139C: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2110]        :                                       		
[2111]        :                                       		; get third row mid cell number (eigth element of randomNumberSequence)
[2112]    139E: BE 56 00                              		lea si, randomNumberSequence
[2113]    13A1: 03 F1                                 		add si, cx
[2114]    13A3: 41                                    		inc cx
[2115]    13A4: 8A 04                                 		mov al, [si]	; copy value from array into al
[2116]    13A6: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2117]        :                                       		
[2118]        :                                       		; write to video memory		
[2119]    13A8: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2120]    13AB: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2121]        :                                       		
[2122]        :                                       		
[2123]        :                                       		
[2124]        :                                       		; -------------------- third row right cell ------------------------ 		
[2125]        :                                       		; calculte third row right cell offset
[2126]    13B0: B8 50 00                              		mov ax, 80	; row length
[2127]    13B3: BA 12 00                              		mov dx, 18	; number of rows
[2128]    13B6: F7 E2                                 		mul dx		; calculate row offset
[2129]    13B8: 05 27 00                              		add ax, 4 + 35	; calculate column
[2130]    13BB: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2131]    13BE: F7 E2                                 		mul dx	    	; mul by 2
[2132]    13C0: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2133]        :                                       		
[2134]        :                                       		; get third row right cell number (ninth element of randomNumberSequence)
[2135]    13C2: BE 56 00                              		lea si, randomNumberSequence
[2136]    13C5: 03 F1                                 		add si, cx
[2137]    13C7: 41                                    		inc cx
[2138]    13C8: 8A 04                                 		mov al, [si]	; copy value from array into al
[2139]    13CA: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2140]        :                                       		
[2141]        :                                       		; write to video memory		
[2142]    13CC: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2143]    13CF: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2144]        :                                       		
[2145]        :                                       		
[2146]        :                                       		
[2147]        :                                       		; -------------------- forth row left cell ------------------------ 		
[2148]        :                                       		; calculte forth row left cell offset
[2149]    13D4: B8 50 00                              		mov ax, 80	; row length
[2150]    13D7: BA 16 00                              		mov dx, 22	; number of rows
[2151]    13DA: F7 E2                                 		mul dx		; calculate row offset
[2152]    13DC: 05 0B 00                              		add ax, 4 + 7	; calculate column
[2153]    13DF: BA 02 00                              		mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2154]    13E2: F7 E2                                 		mul dx	    	; mul by 2
[2155]    13E4: 8B F8                                 		mov di, ax	; di used as offset in video memory
[2156]        :                                       		
[2157]        :                                       		; get forth row left cell number (tenth element of randomNumberSequence)
[2158]    13E6: BE 56 00                              		lea si, randomNumberSequence
[2159]    13E9: 03 F1                                 		add si, cx
[2160]    13EB: 41                                    		inc cx
[2161]    13EC: 8A 04                                 		mov al, [si]	; copy value from array into al
[2162]    13EE: 04 30                                 		add al, '0'	; '0' -> 48 move from ascii code 0 -> 9 to 48 > 47 (visual representatin of the number)
[2163]        :                                       		
[2164]        :                                       		; write to video memory		
[2165]    13F0: 26 88 05                              		mov byte ptr es:[di], al	; write character
[2166]    13F3: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2167]    13F8: C3                                    	ret
[2168]        :                                       renderUI endp	
[2169]        :                                       
[2170]    13F9:                                       resetInputTextArea proc
[2171]        :                                       	
[2172]        :                                       	 	
[2173]        :                                       	; calculte offset to start of input text area
[2174]    13F9: B8 50 00                              	mov ax, 80	; row length
[2175]    13FC: BA 01 00                              	mov dx, 1	; number of rows
[2176]    13FF: F7 E2                                 	mul dx		; calculate row offset
[2177]    1401: 05 05 00                              	add ax, 4 + 1	; calculate column offset
[2178]    1404: BA 02 00                              	mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2179]    1407: F7 E2                                 	mul dx	    	; mul by 2
[2180]    1409: 8B F8                                 	mov di, ax	; di used as offset in video memory
[2181]        :                                       	
[2182]    140B: B9 45 00                              	mov cx, 69
[2183]    140E:                                       	resetCellITALine1:
[2184]        :                                       		; write to video memory		
[2185]    140E: 26 C6 05 20                           		mov byte ptr es:[di], ' '	; write character
[2186]    1412: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2187]    1417: 83 C7 02                              		add di, 2
[2188]    141A: E2 F2                                 	 	loop resetCellITALine1
[2189]    141C: B9 45 00                              	mov cx, 69	; set counter for next line
[2190]    141F: 83 C7 16                              	add di, 22	; offset di to start of next line
[2191]        :                                       	
[2192]    1422:                                       	resetCellITALine2:
[2193]        :                                       		; write to video memory		
[2194]    1422: 26 C6 05 20                           		mov byte ptr es:[di], ' '	; write character
[2195]    1426: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2196]    142B: 83 C7 02                              		add di, 2
[2197]    142E: E2 F2                                 	 	loop resetCellITALine2
[2198]    1430: B9 45 00                              	mov cx, 69	; set counter for next line
[2199]    1433: 83 C7 16                              	add di, 22	; offset di to start of next line
[2200]        :                                       	
[2201]    1436:                                       	resetCellITALine3:
[2202]        :                                       		; write to video memory		
[2203]    1436: 26 C6 05 20                           		mov byte ptr es:[di], ' '	; write character
[2204]    143A: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2205]    143F: 83 C7 02                              		add di, 2
[2206]    1442: E2 F2                                 	 	loop resetCellITALine3	 	
[2207]        :                                       	
[2208]    1444: C3                                    	ret
[2209]        :                                       resetInputTextArea endp
[2210]        :                                       
[2211]        :                                       
[2212]    1445:                                       resetOutputTextArea proc 	
[2213]        :                                       
[2214]        :                                       ; calculte offset to start of input text area
[2215]    1445: B8 50 00                              	mov ax, 80	; row length
[2216]    1448: BA 05 00                              	mov dx, 5	; number of rows
[2217]    144B: F7 E2                                 	mul dx		; calculate row offset
[2218]    144D: 05 05 00                              	add ax, 4 + 1	; calculate column offset
[2219]    1450: BA 02 00                              	mov dx, 2	; each cell is composed of 2 bytes (one for char and next one for attribute)
[2220]    1453: F7 E2                                 	mul dx	    	; mul by 2
[2221]    1455: 8B F8                                 	mov di, ax	; di used as offset in video memory
[2222]        :                                       	
[2223]    1457: B9 29 00                              	mov cx, 41
[2224]    145A:                                       	resetCellOTALine1:
[2225]        :                                       		; write to video memory		
[2226]    145A: 26 C6 05 20                           		mov byte ptr es:[di], ' '	; write character
[2227]    145E: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2228]    1463: 83 C7 02                              		add di, 2
[2229]    1466: E2 F2                                 	 	loop resetCellOTALine1
[2230]    1468: B9 29 00                              	mov cx, 41	; set counter for next line
[2231]    146B: 83 C7 4E                              	add di, 78	; offset di to start of next line
[2232]        :                                       	
[2233]    146E:                                       	resetCellOTALine2:
[2234]        :                                       		; write to video memory		
[2235]    146E: 26 C6 05 20                           		mov byte ptr es:[di], ' '	; write character
[2236]    1472: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2237]    1477: 83 C7 02                              		add di, 2
[2238]    147A: E2 F2                                 	 	loop resetCellOTALine2
[2239]    147C: B9 29 00                              	mov cx, 41	; set counter for next line
[2240]    147F: 83 C7 4E                              	add di, 78	; offset di to start of next line
[2241]        :                                       	
[2242]    1482:                                       	resetCellOTALine3:
[2243]        :                                       		; write to video memory		
[2244]    1482: 26 C6 05 20                           		mov byte ptr es:[di], ' '	; write character
[2245]    1486: 26 C6 45 01 40                        		mov byte ptr es:[di+1], 0x40	; write attribute byte defined as red background, black foreground
[2246]    148B: 83 C7 02                              		add di, 2
[2247]    148E: E2 F2                                 	 	loop resetCellOTALine3	 	
[2248]        :                                       	 	
[2249]    1490: C3                                    	ret
[2250]        :                                       resetOutputTextArea endp	
[2251]        :                                       
[2252]    1491:                                       exitProgram proc
[2253]        :                                       	
[2254]        :                                       	; when exiting the aplication, DOS console does not reset the video memory,
[2255]        :                                       	; meaning that the calculator will still be visible
[2256]        :                                       	; Because of this, we will manually reset the background to all black before exiting the application
[2257]        :                                       
[2258]    1491: 33 FF                                 	xor di, di	; di = 0 (start of video memory)
[2259]        :                                       	
[2260]    1493: B4 09                                 	mov ah, 09h	; write character(al) and attribute(bl)
[2261]    1495: B0 20                                 	mov al, ' '	; character
[2262]    1497: B3 0F                                 	mov bl, 0fh	; attribute byte (black background, white foreground)
[2263]    1499: B7 00                                 	mov bh, 0	; page 0
[2264]        :                                       				
[2265]    149B: B9 A0 0F                              	mov cx, 4000	; number of spaces to fill (80 columns * 25 rows) * 2 (each cell of the console window is 2 bytes)
[2266]    149E: CD 10                                 	int 10h
[2267]        :                                       		
[2268]    14A0: B8 00 4C                              	mov ax, 4c00h   ; exit program
[2269]    14A3: CD 21                                 	int 21h
[2270]        :                                       		
[2271]    14A5: C3                                    	ret	
[2272]        :                                       exitProgram endp	
[2273]        :                                       
[2274]        :                                       	
[2275]        :                                       END
[2276]        :                                       
 
===================================================================================================
 
EXE HEADER - bytes from 0000 to 01FF inclusive.

0000: 4D      -   exe signature (M)
0001: 5A      -   exe signature (Z)
0002: A6      -   bytes on last page (l.byte)
0003: 00      -   bytes on last page (h.byte)
0004: 0C      -   512 byte pages in file (l.byte)
0005: 00      -   512 byte pages in file (h.byte)
0006: 01      -   relocations (l.byte)
0007: 00      -   relocations (h.byte)
0008: 20      -   paragraphs in header (l.byte)
0009: 00      -   paragraphs in header (h.byte)
000A: 00      -   minimum memory (l.byte)
000B: 00      -   minimum memory (h.byte)
000C: FF      -   maximum memory (l.byte)
000D: FF      -   maximum memory (h.byte)
000E: 00      -   SS - stack segment (l.byte)
000F: 00      -   SS - stack segment (h.byte)
0010: 00      -   SP - stack pointer (l.byte)
0011: 01      -   SP - stack pointer (h.byte)
0012: FE      -   check sum (l.byte)
0013: 94      -   check sum (h.byte)
0014: 00      -   IP - instruction pointer (l.byte)
0015: 00      -   IP - instruction pointer (h.byte)
0016: 93      -   CS - code segment (l.byte)
0017: 00      -   CS - code segment (h.byte)
0018: 1E      -   relocation table adress (l.byte)
0019: 00      -   relocation table adress (h.byte)
001A: 00      -   overlay number (l.byte)
001B: 00      -   overlay number (h.byte)
001C: 01      -   signature (l.byte)
001D: 00      -   signature (h.byte)
001E: B3      -   relocation table - offset inside segment (l.byte)
001F: 08      -   relocation table - offset inside segment (h.byte)
0020: 93      -   relocation table - segment anchor (l.byte)
0021: 00      -   relocation table - segment anchor (h.byte)
0022 to 01FF  -   reserved relocation area  (00) 




===================================================================================================

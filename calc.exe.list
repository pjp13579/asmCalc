EMU8086 GENERATED LISTING. MACHINE CODE <- SOURCE.
 
calc.exe -- emu8086 assembler version: 4.05  
 
[ 12/21/2024  --  1:41:29 PM ] 
 
===================================================================================================
[LINE]     LOC: MACHINE CODE                          SOURCE
===================================================================================================
 
[   0]        :                                       ;calculator
[   1]        :                                       .MODEL SMALL
[   2]        :                                       
[   3]        :                                       .stack 256
[   4]        :                                       
[   5]        :                                       .DATA
[   6]        :                                       	; text data
[   7]    0100: 69 6E 70 75 74 3A 20 24               	inputPromt db 'input: $'		
[   8]    0108: 20 3D 20 24                           	resultPreText db ' = $'
[   9]    010C: 0D 0A 24                              	newline db 13, 10, '$'			; Carriage Return and Line Feed make up a newline.
[  10]    010F: 08 20 08 24                           backspace_string db 8, ' ', 8, '$'	; meant to be used for data validation, when user does not press the backspace key
[  11]    0113: 20 08 24                              removeCurrentCharacter db ' ', 8, '$'   ; meant to be used when user presses the backspace key
[  12]    0116: 20 24                                 addSpace db 32, '$'			; prints a space ' '
[  13]    0118: 2D 24                                 negativeResultString db 45, '$'         ; prints a minus '-'
[  14]        :                                       
[  15]        :                                       
[  16]        :                                       	; data for result output
[  17]    011A: 00 00 00 00 00 00 00 00               	result db length dup(0)		; output result array
[  18]    0122: 00                                    	resultSign db 0			; represents the sign of the result of an operation with unsigned numbers
[  19]    0123: 00 00                                 mem3 dw 0		; reserved to reference result array memory address
[  20]        :                                       
[  21]        :                                       
[  22]        :                                       	; main variables
[  23]        :                                       	; length should be an even number
[  24]        :                                       	length equ 8			; define constant with the length of the numbers
[  25]        :                                       	lengthTimesTwo equ length * 2	; for the multiplication result. The maximum size of the result will be the sum of the length of both operands (operands are of the same size, and therefore time 2)		
[  26]    0125: 00 00 00 00 00 00 00 00               	numberOne db length dup(0)	; input number 1 array
[  27]    012D: 00 00 00 00 00 00 00 00               	numberTwo db length dup(0)	; input number 2 array
[  28]    0135: 00 00                                 	mem1 dw 0			; reserved to reference operand 1 array memory address
[  29]    0137: 00 00                                 	mem2 dw 0			; reserved to reference operand 2 array memory address
[  30]    0139: 00                                    	operation db 0			; specifies the operation between the numbers (+, - , /, v (v -> sqrt, only uses one number))
[  31]        :                                       	
[  32]        :                                       	
[  33]        :                                       	; variable for subtraction
[  34]    013A: 00                                    	anotherCarryFlag db 0		; used in subtraction to define a carry value between iterations
[  35]        :                                       			
[  36]        :                                       	
[  37]        :                                       	; variables for multiplication	
[  38]    013B: 00                                    	anotherCounter db 0	; used for multiplication algorithm	
[  39]    013C: 00 00 00 00 00 00 00 00               	tmp1 db length dup(0)	; reserved for mulDiv, carries the result between iterations
[  40]    0144: 00 00 00 00 00 00 00 00               	tmp2 db length dup(0)	; reserved for mulDiv, used to subtract the second operand in each iteration
[  41]    014C: 00 00 00 00 00 00 00 00               	tmp3 db length dup(0)	; reserved for mulDiv, used to determine the greatest coeficient of divisor (that's it's mutiplication by divisor is lower than the remainder)
[  42]    0154: 00 00 00 00 00 00 00 00               	tmp5 db length dup(0)	; reserved for mulDiv, used to copy the second operand into a discartable array
[  43]        :                                       	
[  44]        :                                       	
[  45]        :                                       	; varaibles for division	
[  46]    015C: 00 00 00 00 00 00 00 00               	remainder db length dup(0)	; input number 2 array
[  47]    0164: 00                                    	coeficient db 0			; references the coeficient in the divisor algorithm
[  48]    0165: 00 00 00 00 00 00 00 00               	quotient db length dup(0)	; ouput quotient
[  49]    016D: 00                                    	dividendPointer db 0	
[  50]    016E: 00 00 00 00 00 00 00 00               	tmp6 db length dup(0)	; reserved for integerDivision, used to copy the coeficient into a discartable array
[  51]    0176: 00 00 00 00 00 00 00 00               	tmp7 db length dup(0)	; reserved for integerDivision, used to copy the second operand into a discartable array
[  52]    017E: 00 00 00 00 00 00 00 00               	tmp4 db length dup(0)	; reserved for integerDivision, used to copy the result value to be then used as param for subtraction
[  53]        :                                       	
[  54]        :                                       	; variables for sqrt
[  55]    0186: 00 00 00 00 00 00 00 00               	root db length dup(0)
[  56]    018E: 00                                    	rootPointer db 0
[  57]    018F: 00                                    	rootCoeficient db 0
[  58]    0190: 00 00 00 00 00 00 00 00               	aux db length dup(0)
[  59]    0198: 00 00 00 00 00 00 00 00               	tmp8 db length dup(0)	; reserved for sqrt, contains the base value for each iteration 			
[  60]    01A0: 00 00 00 00 00 00 00 00               	tmp9 db length dup(0)	; reserved for sqrt, contains the '2' and rootCoeficient operand
[  61]    01A8: 00 00 00 00 00 00 00 00               	tmp10 db length dup(0)	; reserved for sqrt, contains the result of the rootCoeficient addition, will act as input for the rootCoeficient multiplication
[  62]    01B0: 00 00 00 00 00 00 00 00               	tmp11 db length dup(0)	; reserved for sqrt, contains the highest tmp value that's also below aux value
[  63]        :                                       	
[  64]        :                                       	; helper variables	
[  65]    01B8: 00 00                                 	mem4 dw 0		; available
[  66]    01BA: 00 00                                 	mem5 dw 0		; available 	
[  67]        :                                       
[  68]        :                                       .CODE
[  69]        :                                       
[  70]    01C0:                                       MAIN PROC
[  71]        :                                       	
[  72]    01C0: E8 35 06                              	call config	; initial configurations 	
[  73]        :                                       
[  74]    01C3:                                       mainCycle:
[  75]    01C3: BA 00 00                              		lea dx, inputPromt	; load address of number1 prompt message for input procedure
[  76]    01C6: B4 09                                 		mov ah, 09h		; load function to print out sting in DX
[  77]    01C8: CD 21                                 		int 21h			; execute 09h
[  78]        :                                       	
[  79]    01CA: BE 25 00                              	lea si, numberOne	; load address of number1 array for input procedure
[  80]    01CD: E8 19 05                              	call zeroNumber		; zero every digit of the array
[  81]    01D0: E8 23 05                              	call readNumberInput	; read input of first number
[  82]        :                                       
[  83]    01D3: BE 2D 00                              	lea si, numberTwo       ; load address of number2 array for input procedure
[  84]    01D6: E8 10 05                              	call zeroNumber		; zero every digit of the array
[  85]    01D9: E8 1A 05                              	call readNumberInput	; read input of second number
[  86]        :                                       	
[  87]    01DC: E8 27 00                              	call preformOperation	; maps te value in operation to the corresponding procedure
[  88]        :                                       	
[  89]    01DF: E8 EE 05                              	call putanewlineintheconsole    ; does what the procedure name says
[  90]        :                                       	
[  91]    01E2: E8 C8 04                              	call outputResult       ; prints the result to the console
[  92]        :                                       	
[  93]    01E5: E8 E8 05                              	call putANewLineInTheConsole	; does what the procedure name says
[  94]    01E8: E8 E5 05                              	call putANewLineInTheConsole	; does what the procedure name says
[  95]    01EB: E8 E2 05                              	call putANewLineInTheConsole	; does what the procedure name says
[  96]        :                                       	         	
[  97]        :                                       		; reset variables, the code flow requires these variables to be 0 at the begining of each operation
[  98]    01EE: BE 1A 00                              	lea si, result		; zero every digit of the result
[  99]    01F1: E8 F5 04                              	call zeroNumber
[ 100]    01F4: BE 65 00                              	lea si, quotient        ; zero every digit of the division quotient
[ 101]    01F7: E8 EF 04                              	call zeroNumber         		
[ 102]    01FA: C6 06 39 00 00                        	mov operation, 0	; zero operation
[ 103]    01FF: C6 06 22 00 00                        	mov resultSign, 0       ; set result sign to positive        	
[ 104]        :                                       	
[ 105]    0204: EB BD                                 	jmp mainCycle		; repeat
[ 106]        :                                       
[ 107]        :                                       MAIN ENDP
[ 108]        :                                       
[ 109]    0206:                                       preformOperation proc
[ 110]        :                                       
[ 111]    0206: BE 25 00                              	lea si, numberOne
[ 112]    0209: 89 36 35 00                           	mov mem1, si		; first operand
[ 113]        :                                       	
[ 114]    020D: BF 2D 00                              	lea di, numberTwo
[ 115]    0210: 89 3E 37 00                           	mov mem2, di   		; second operand
[ 116]        :                                       	
[ 117]    0214: BB 1A 00                              	lea bx, result
[ 118]    0217: 89 1E 23 00                           	mov mem3, bx
[ 119]        :                                       	
[ 120]    021B: 80 3E 39 00 2B                        	cmp operation, '+'
[ 121]    0220: 75 03 E9 23 04                        	je addNumbers
[ 122]        :                                       	
[ 123]    0225: 80 3E 39 00 2D                        	cmp operation, '-'
[ 124]    022A: 75 03 E9 BF 03                        	je subNumbers
[ 125]        :                                       	
[ 126]    022F: 80 3E 39 00 2A                        	cmp operation, '*'
[ 127]    0234: 75 03 E9 38 03                        	je mulSetup
[ 128]        :                                       	
[ 129]    0239: 80 3E 39 00 2F                        	cmp operation, '/'
[ 130]    023E: 75 03 E9 70 01                        	je integerDivision
[ 131]        :                                       	
[ 132]    0243: 80 3E 39 00 76                        	cmp operation, 'v'
[ 133]    0248: 74 01                                 	je sqrt
[ 134]        :                                       	
[ 135]        :                                       	; cmp operation, 'n'
[ 136]        :                                       	; je nifValidator
[ 137]        :                                       	
[ 138]        :                                       	; cmp operation, 'c'
[ 139]        :                                       	; je ccValidator
[ 140]        :                                       	
[ 141]        :                                       	; cmp operation, 'b'
[ 142]        :                                       	; je ean13BarCodeValidator
[ 143]        :                                       
[ 144]    024A: C3                                    ret
[ 145]        :                                       preformOperation endp
[ 146]        :                                       
[ 147]    024B:                                       sqrt proc
[ 148]    024B: BE 86 00                              lea si, root
[ 149]    024E: E8 98 04                              call zeroNumber
[ 150]    0251: BE 90 00                              lea si, aux
[ 151]    0254: E8 92 04                              call zeroNumber
[ 152]    0257: BE 98 00                              	lea si, tmp8
[ 153]    025A: E8 8C 04                              call zeroNumber           		
[ 154]    025D: BE A0 00                              lea si, tmp9
[ 155]    0260: E8 86 04                              call zeroNumber           		
[ 156]    0263: BE A8 00                              lea si, tmp10
[ 157]    0266: E8 80 04                              call zeroNumber
[ 158]    0269: C6 06 8E 00 00                        mov rootPointer, 0
[ 159]        :                                       		
[ 160]    026E:                                       	updateAux:
[ 161]        :                                       	; multiply by 100 and add the dozens and unit digit -> aux = ( aux * 100 ) + rootPointer[i] + rootPointer[i + 1]	
[ 162]        :                                       	
[ 163]        :                                       	; lea di, axu	
[ 164]        :                                       	; cmp []
[ 165]        :                                       	
[ 166]    026E:                                       	updateAuxStart:
[ 167]        :                                       	
[ 168]        :                                       	
[ 169]    026E: BF 90 00                              	lea di, aux			
[ 170]    0271: E8 29 01                              	call multiplyBy100	
[ 171]        :                                       	
[ 172]    0274: 33 C0                                 	xor ax, ax
[ 173]        :                                       
[ 174]    0276: BF 96 00                              	lea di, aux + length - 2	; load dozens place
[ 175]        :                                       	
[ 176]        :                                       ; copy dozens digit
[ 177]    0279: BE 2D 00                              lea si, numberTwo	; set si to beggining of number2
[ 178]    027C: A0 8E 00                              mov al, rootPointer
[ 179]    027F: 03 F0                                 add si, ax		; point to rootPointer offset
[ 180]    0281: 8A 04                                 mov al, [si]		; indirectly reference value
[ 181]    0283: 88 05                                 mov [di], al            ; insert number in memory address
[ 182]        :                                       
[ 183]    0285: FE 06 8E 00                           inc rootPointer
[ 184]    0289: 47                                    inc di
[ 185]    028A: 33 C0                                 	xor ax, ax
[ 186]        :                                       	
[ 187]        :                                       ; copy units digit
[ 188]    028C: BE 2D 00                              lea si, numberTwo	; set si to beggining of number2
[ 189]    028F: A0 8E 00                              mov al, rootPointer
[ 190]    0292: 03 F0                                 add si, ax		; point to rootPointer offset
[ 191]    0294: 8A 04                                 mov al, [si]            ; indirectly reference value
[ 192]    0296: 88 05                                 mov [di], al            ; insert number in memory address
[ 193]    0298: FE 06 8E 00                           inc rootPointer		; this increment will set rootPointer ready for the next iteration
[ 194]        :                                       
[ 195]    029C: C6 06 8F 00 00                        	mov rootCoeficient, 0
[ 196]        :                                       	
[ 197]    02A1: BE A0 00                              	lea si, tmp9	
[ 198]    02A4: E8 42 04                              	call zeroNumber	; set tmp9 to zero before cycle. tmp9 is expected to be 0 at the start
[ 199]        :                                       	        	    	
[ 200]    02A7:                                       	rootMulTable:
[ 201]        :                                       	; 1. calculate tmp value -> tmp = ( ( ( root * 2 ) * 10 ) + i ) * i , with i ranging from 0 to 9. i variable will be called rootCoeficient
[ 202]        :                                       	; 	Calculate ( ( root * 2 ) * 10 ), it will hold the base value for each iteration of the remainging operation with the incrementable variable i
[ 203]        :                                       	;	Do not override the base value, it will be the same for every iteration
[ 204]        :                                       	;	Use the base value, add i and then multiply by i	
[ 205]        :                                       	
[ 206]        :                                       	; 2. on each iteration validate if it's above aux
[ 207]        :                                       	; 2.1 if true, decrease i, and continue to step 3
[ 208]        :                                       	; 2.2 if false, increase i, and re-calculate tmp	
[ 209]        :                                       	
[ 210]    02A7:                                       	rootStepTwoCalculateBaseValue:
[ 211]        :                                       	
[ 212]        :                                       	; 1. calculate tmp value -> tmp = ( ( ( current root value * 2 ) * 10 ) + i ) * 1
[ 213]        :                                       	
[ 214]        :                                       	; ( current root value * 2 )
[ 215]        :                                       	
[ 216]        :                                       	; define second operand '2'		
[ 217]    02A7: BF A7 00                              	lea di, tmp9 + length -	1	; change only the units digit
[ 218]    02AA: C6 05 02                              	mov [di], 2		
[ 219]        :                                       	
[ 220]        :                                       	; preform multiplication -> current root value * 2
[ 221]    02AD: BF 86 00                              	lea di, root	; indirectly reference root array
[ 222]    02B0: 89 3E 35 00                           	mov mem1, di	; divMul input param for first operand
[ 223]        :                                       	
[ 224]    02B4: BF A0 00                              	lea di, tmp9	; indirectly reference tmp9  array
[ 225]    02B7: 89 3E 37 00                           	mov mem2, di	; divMul input param for second operand
[ 226]        :                                       	
[ 227]    02BB: BF 1A 00                              	lea di, result	; result
[ 228]    02BE: 89 3E 23 00                           	mov mem3, di	; divMul input param for result array
[ 229]        :                                       			 			 		      	
[ 230]    02C2: E8 1B 02                              call mulDiv	; multiplicate root by 2	
[ 231]        :                                       
[ 232]        :                                       ; reset auxiliary array
[ 233]    02C5: BF A7 00                              lea di, tmp9 + length - 1	; only nedeed to change the units digit
[ 234]    02C8: C6 05 00                              	mov [di], 0	; set tmp9 value back to 0
[ 235]        :                                       	
[ 236]        :                                       	; ( current root value * 2 ) * 10
[ 237]    02CB: BF 1A 00                              	lea di, result
[ 238]    02CE: E8 BA 00                              	call multiplyBy10
[ 239]        :                                       	
[ 240]        :                                       	; save the base value (current root value * 2)
[ 241]    02D1: BE 1A 00                              	lea si, result
[ 242]    02D4: BF 98 00                              	lea di, tmp8
[ 243]    02D7: B9 08 00                              	mov cx, length
[ 244]    02DA: E8 96 03                              	call copyArray
[ 245]        :                                       	
[ 246]        :                                       	; reset result
[ 247]    02DD: BE 1A 00                              lea si, result
[ 248]    02E0: E8 06 04                              call zeroNumber
[ 249]        :                                       	
[ 250]    02E3:                                       	iterateOverRootValuePreformOperationAndValidate:
[ 251]        :                                       	
[ 252]        :                                       	        ; reset result
[ 253]    02E3: BE 1A 00                              	lea si, result
[ 254]    02E6: E8 00 04                              	call zeroNumber
[ 255]        :                                       	
[ 256]        :                                       		; preform the remaining operations, adding i to the base value and then multiply it by i
[ 257]        :                                       		
[ 258]        :                                       		; add i -> baseValue + i
[ 259]        :                                       		
[ 260]    02E9: BE 98 00                              		lea si, tmp8			; set first operand, base value
[ 261]    02EC: BF A7 00                              		lea di, tmp9 + length - 1	; load the place where to put the rootCoeficient value	
[ 262]    02EF: A0 8F 00                              		mov al,	rootCoeficient		; get rootCoeficient value and put in ax for indirect transfer			
[ 263]    02F2: 88 05                                 		mov [di], al			; put the root coeficient in the units place of the tmp9 array
[ 264]    02F4: BF A0 00                              		lea di, tmp9			; set second operand, reset the position to the start of the array
[ 265]    02F7: BB 1A 00                              		lea bx, result			; set result array
[ 266]    02FA: E8 4B 03                              		call addNumbers
[ 267]        :                                       		
[ 268]        :                                       		; save the result in intermediary variable to be used as input for the multiplication
[ 269]    02FD: BE 1A 00                              		lea si, result	; copy origin
[ 270]    0300: BF A8 00                              		lea di, tmp10	; copy destination
[ 271]    0303: E8 6D 03                              		call copyArray	; preform copy
[ 272]        :                                       		
[ 273]        :                                       		; reset result
[ 274]    0306: BE 1A 00                              		lea si, result
[ 275]    0309: E8 DD 03                              		call zeroNumber
[ 276]        :                                       		
[ 277]        :                                       		; multiply by i -> (baseValue + i) * 1
[ 278]    030C: BE A8 00                              		lea si, tmp10	; set first operand for multiplication
[ 279]    030F: 89 36 35 00                           		mov mem1, si	; set first operand for multiplication
[ 280]        :                                       		
[ 281]    0313: BE A7 00                              		lea si, tmp9 + length - 1	; set value for the second operand for multiplication, root coeficient
[ 282]    0316: A0 8F 00                              		mov al,	rootCoeficient
[ 283]    0319: 88 04                                 		mov [si], al	; set value for the second operand for multiplication, root coeficient
[ 284]    031B: BE A0 00                              		lea si, tmp9
[ 285]    031E: 89 36 37 00                           		mov mem2, si
[ 286]        :                                       		
[ 287]    0322: BE 1A 00                              		lea si, result
[ 288]    0325: 89 36 23 00                           		mov mem3, si
[ 289]        :                                       		
[ 290]    0329: E8 B4 01                              		call muldiv	; preform multiplication				                                				                                		
[ 291]        :                                       	
[ 292]        :                                       	; 2 stop conditions for the coeficient step
[ 293]        :                                       	; Coeficient found or reached max number of iterations. Stop when any of them hits
[ 294]        :                                       	
[ 295]        :                                       	; First
[ 296]        :                                       	; Validate if the result is above to aux ( bx = 1 )
[ 297]        :                                       	; If is is below( bx = 0 ), increase the root coeficient by one and try again
[ 298]        :                                       	; until the result is above or equal to the aux
[ 299]        :                                       	
[ 300]        :                                       	; validate if result is above or equal to the remainder
[ 301]    032C: BE 90 00                              	lea si, aux		
[ 302]    032F: BF 1A 00                              		lea di, result        	        	        	
[ 303]    0332: E8 57 03                              	call determineSubtractionSign	; result in bx        	
[ 304]    0335: 83 FB 01                              	cmp bx, 1
[ 305]    0338: 74 16                                 	je updateAuxAndRoot        	        	
[ 306]        :                                       	
[ 307]        :                                       	; Second
[ 308]        :                                       	; Stop after 9 was processed has a possible coeficient.
[ 309]        :                                       	; When this happens, the inc below will overflow coeficient by one. We'll fix it a couple lines below
[ 310]    033A: 80 3E 8F 00 0A                        	cmp rootCoeficient, 10
[ 311]    033F: 73 0F                                 	jae updateAuxAndRoot        	        	
[ 312]        :                                       	
[ 313]        :                                       	; save the result in intermediary variable to be used to update aux value in step 3
[ 314]    0341: BE 1A 00                              		lea si, result	; copy origin
[ 315]    0344: BF B0 00                              		lea di, tmp11	; copy destination
[ 316]    0347: E8 29 03                              		call copyArray	; preform copy
[ 317]        :                                       		
[ 318]    034A: FE 06 8F 00                           		inc rootCoeficient				
[ 319]        :                                       		
[ 320]    034E: EB 93                                 		jmp iterateOverRootValuePreformOperationAndValidate
[ 321]        :                                       		
[ 322]    0350:                                       	updateAuxAndRoot:
[ 323]        :                                       	
[ 324]    0350: FE 0E 8F 00                           	dec rootCoeficient	; fix rootCoeficient overflow
[ 325]        :                                       	
[ 326]        :                                       	; step 3. Update Aux and Root result
[ 327]        :                                       	
[ 328]        :                                       	; update aux -> aux = aux - tmp
[ 329]        :                                       	; update root -> root = ( root * 10 ) + 1
[ 330]        :                                       	
[ 331]        :                                       	; update aux
[ 332]    0354: BE 90 00                              	lea si, aux	
[ 333]    0357: BF B0 00                              	lea di, tmp11   ; result tmp result was saved in tmp10
[ 334]    035A: BB 1A 00                              	lea bx, result
[ 335]    035D: E8 52 02                              	call subNumbersMul
[ 336]        :                                       	
[ 337]    0360: BE 1A 00                              	lea si, result	; copy origin
[ 338]    0363: BF 90 00                              	lea di, aux	; copy destination
[ 339]    0366: E8 0A 03                              	call copyArray	; preform copy
[ 340]        :                                       	
[ 341]        :                                       	; update root
[ 342]    0369: BF 86 00                              	lea di, root
[ 343]    036C: E8 1C 00                              	call multiplyBy10
[ 344]        :                                       	
[ 345]    036F: BF 8D 00                              	lea di, root + length - 1
[ 346]    0372: A0 8F 00                              	mov al, rootCoeficient
[ 347]    0375: 88 05                                 	mov [di], al
[ 348]        :                                       	
[ 349]        :                                       	; step 4. Validate end of algorithm
[ 350]        :                                       	; if the rootPointer >= length
[ 351]        :                                       	; if yes, finito
[ 352]        :                                       	; if no, increment rootPointer and go to step 2
[ 353]        :                                       	
[ 354]    0377: 80 3E 8E 00 08                        	cmp rootPointer, length
[ 355]    037C: 73 03                                 	jae sqrtFinished
[ 356]        :                                       	
[ 357]    037E: E9 ED FE                              	jmp updateAux	
[ 358]        :                                       	
[ 359]    0381:                                       	sqrtFinished:
[ 360]        :                                       	
[ 361]    0381: BE 86 00                              	lea si, root	; copy origin
[ 362]    0384: BF 1A 00                              	lea di, result	; copy destination
[ 363]    0387: E8 E9 02                              	call copyArray	; preform copy
[ 364]        :                                       	 	
[ 365]    038A: C3                                    	ret		
[ 366]        :                                       sqrt endp
[ 367]        :                                       
[ 368]    038B:                                       multiplyBy10 proc
[ 369]        :                                       	
[ 370]        :                                       	; input: di should point to the array start
[ 371]        :                                       	
[ 372]        :                                       
[ 373]        :                                       
[ 374]        :                                       	; mov al, 1	; indirectly reference 1
[ 375]        :                                       	; cmp al, length	; if the amount of digits is equal to 1, cx will wrap around and bug everything
[ 376]        :                                       	; jae mulByTenUnitDigit
[ 377]        :                                       
[ 378]        :                                       ; caution: ax is reset in this proc
[ 379]    038B: B8 00 00                              mov ax, 0
[ 380]        :                                       
[ 381]        :                                       ; to multiply by 10, we'll shift each element once to the left (excluding right-most element)
[ 382]    038E: B9 07 00                              	mov cx, length - 1	; preform one less shift, because that one last shift would pull data from outside the array memory space, this position should be zero				
[ 383]        :                                       		
[ 384]    0391:                                       	leftShiftAuxMulBy10:		; increase every digit by a order of magnitude
[ 385]    0391: 8A 45 01                              		mov al, [di + 1]	; get the digit at the right of the current position
[ 386]    0394: 88 05                                 		mov [di], al            ; override current digit with the one at it's right
[ 387]    0396: 47                                    		inc di			; move si into the next lower significance digit
[ 388]    0397: E2 F8                                 		loop leftShiftAuxMulBy10
[ 389]        :                                       	
[ 390]    0399:                                       	mulByTenUnitDigit:
[ 391]    0399: C6 05 00                              	mov [di], 0	; set units digit to 0	
[ 392]        :                                       
[ 393]    039C: C3                                    	ret
[ 394]        :                                       	
[ 395]        :                                       multiplyBy10 endp
[ 396]        :                                       
[ 397]    039D:                                       multiplyBy100 proc
[ 398]        :                                       	
[ 399]        :                                       	; input: di should point to the array start
[ 400]        :                                       	
[ 401]        :                                       	
[ 402]        :                                       ; mov al, 2	; indirectly reference 2
[ 403]        :                                       ; cmp al, length	; if the amount of digits is equal or below of 2, cx will wrap around and bug everything
[ 404]        :                                       	; jae mulByOneHundredUnitAndDozenDigit
[ 405]        :                                       
[ 406]        :                                       	; caution: ax is reset in this proc
[ 407]    039D: B8 00 00                              mov ax, 0
[ 408]        :                                       	
[ 409]        :                                       	; to multiply by 100, we'll shift each element twice to the left (excluding left-most two elements)
[ 410]    03A0: B9 06 00                              	mov cx, length - 2	; preform two less shifts, because those two last shifts would pull data from outside the array bounds
[ 411]        :                                       		
[ 412]    03A3:                                       	leftShiftAuxMulBy100:		; increase every digit by a order of magnitude
[ 413]    03A3: 8A 45 02                              		mov al, [di + 2]	; get the digit at the right of the current position
[ 414]    03A6: 88 05                                 		mov [di], al            ; override current digit with the one at it's right
[ 415]    03A8: 47                                    		inc di			; move si into the next lower significance digit
[ 416]    03A9: E2 F8                                 		loop leftShiftAuxMulBy100
[ 417]        :                                       	
[ 418]    03AB:                                       	mulByOneHundredUnitAndDozenDigit:
[ 419]    03AB: C6 05 00                              	mov [di], 0	; set dozens digit to 0
[ 420]        :                                       	
[ 421]    03AE: 47                                    	inc di		; move to the units digit
[ 422]    03AF: C6 05 00                              	mov [di], 0	; set units digit to 0
[ 423]        :                                       	
[ 424]    03B2: C3                                    	ret	
[ 425]        :                                       multiplyBy100 endp
[ 426]        :                                       
[ 427]    03B3:                                       integerDivision proc
[ 428]    03B3: BE 5C 00                              	lea si, remainder       ; zero every digit of the remainder         	
[ 429]    03B6: E8 30 03                              call zeroNumber
[ 430]    03B9: C6 06 64 00 00                        mov coeficient, 0       ; zero division quotient
[ 431]    03BE: C6 06 6D 00 00                        mov dividendPointer, 0                         		
[ 432]    03C3:                                       	updateRemainder:
[ 433]        :                                       	
[ 434]        :                                       		; update remainder
[ 435]        :                                       		; remainder = remainder * 10 + dividend[dividendPointer]
[ 436]        :                                       	
[ 437]        :                                       		; increase current number in remainder by 1 order of magnitude		
[ 438]    03C3: BE 5C 00                              		lea si, remainder	; start at the leftmost position of the array and override it with the next digit
[ 439]    03C6: BA 00 00                              		mov dx, 0		; reset dx
[ 440]    03C9: 8A 16 6D 00                           		mov dl, dividendPointer
[ 441]    03CD: BF 25 00                              		lea di, numberOne
[ 442]    03D0: 03 FA                                 		add di, dx              ; move di into the dividend unit defined by dividend pointer
[ 443]    03D2: B9 07 00                              		mov cx, length - 1	; preform one less shift, because that one last shift would pull data from outside the array memory space				
[ 444]        :                                       		
[ 445]    03D5:                                       		leftShiftRemainder:		; increase every digit by a order of magnitude
[ 446]    03D5: 8A 44 01                              			mov al, [si + 1]	; get the digit at the right of the current position
[ 447]    03D8: 88 04                                 			mov [si], al            ; override current digit with the one at it's right
[ 448]    03DA: 46                                    			inc si			; move si into the next lower significance digit
[ 449]    03DB: E2 F8                                 			loop leftShiftRemainder	; repeat for remaining digits
[ 450]        :                                       			
[ 451]        :                                       		; add the unit digit
[ 452]    03DD: 8A 05                                 		mov al, [di]	; select the digit from dividend to put in the units place of remainder
[ 453]    03DF: 88 04                                 		mov [si], al	; move into the remainder
[ 454]        :                                       		
[ 455]        :                                       		; determine if the remainder is greater or equal to the divisor
[ 456]    03E1: BE 5C 00                              		lea si, remainder	
[ 457]    03E4: BF 2D 00                              		lea di, numberTwo
[ 458]        :                                       		
[ 459]    03E7: E8 A2 02                              		call determineSubtractionSign ; determine if the remainder is above or equal to the divisor (0 greater or equal, 1 below)
[ 460]        :                                       		
[ 461]    03EA: 83 FB 00                              		cmp bx, 0 ; if bx is 0, the remainder is above or equal to the divisor
[ 462]    03ED: 74 0F                                 		je determineDivisorCoeficient
[ 463]        :                                       		
[ 464]    03EF: 8A 16 6D 00                           		mov dl, dividendPointer ; dividend pointer
[ 465]    03F3: 80 FA 07                              	cmp dl, length - 1	; stop when the dividen pointer value reached the lenght of the dividend
[ 466]    03F6: 74 06                                 		je determineDivisorCoeficient
[ 467]        :                                       		     		
[ 468]    03F8: FE 06 6D 00                           		inc dividendPointer
[ 469]    03FC: EB C5                                 		jmp updateRemainder		
[ 470]        :                                       	     	
[ 471]        :                                       	
[ 472]    03FE:                                       	determineDivisorCoeficient:	; find the greatest coeficient of divisor such that it's below or equal to the remainder
[ 473]        :                                       	
[ 474]        :                                       	        ; WARNING: do not change coeficient to cx cus it calls the determineSubtractionSign and it overrides cx. using coeficient is safe
[ 475]        :                                       	        ; starting at 0 and incrementing. Starting at 9 will take longer most of the times
[ 476]    03FE: C6 06 64 00 00                        		mov coeficient, 0	; divisor coeficient (0, 1, 2, ..., 8, 9)
[ 477]        :                                       		
[ 478]    0403:                                       		findDivisorCoeficient:
[ 479]        :                                       			; in order to use multiplication, both operands need to be arrays of digits
[ 480]        :                                       			; we're mapping our multiplication increment to an array and send it as that
[ 481]    0403: BF 53 00                              			lea di, tmp3 + length - 1	; load the address of the last (rightmost, least significant) element of tmp3 array. Used to represent the coeficient number in an array	
[ 482]    0406: A0 64 00                              			mov al, coeficient
[ 483]    0409: 88 05                                 			mov [di], al		; move the coeficient value into least significant position of tmp array
[ 484]        :                                       					
[ 485]    040B: BF 2D 00                              			lea di, numberTwo	; divisior
[ 486]    040E: 89 3E 35 00                           			mov mem1, di
[ 487]        :                                       	
[ 488]    0412: BF 4C 00                              			lea di, tmp3		; coeficient
[ 489]    0415: 89 3E 37 00                           			mov mem2, di
[ 490]        :                                       	
[ 491]    0419: BF 1A 00                              			lea di, result		; result
[ 492]    041C: 89 3E 23 00                           			mov mem3, di
[ 493]        :                                       			 			 		      	
[ 494]    0420: E8 BD 00                              		call mulDiv		; multiplicate coeficient by divisor      		
[ 495]        :                                       		
[ 496]        :                                       		; validate if result is above or equal to the remainder
[ 497]    0423: BE 1A 00                              		lea si, result		
[ 498]    0426: BF 5C 00                              			lea di, remainder 	
[ 499]    0429: E8 60 02                              		call determineSubtractionSign	; result in bx
[ 500]        :                                       		
[ 501]        :                                       		; reset result
[ 502]    042C: BE 1A 00                              		lea si, result
[ 503]    042F: E8 B7 02                              		call zeroNumber
[ 504]        :                                       		
[ 505]        :                                       		; 2 stop conditions for the coeficient step
[ 506]        :                                       		; Coeficient found or reached max number of iterations. Stop when any of them hits
[ 507]        :                                       	
[ 508]        :                                       		; First
[ 509]        :                                       		; Validate if the mutiplication of the coeficient by the divisor is above or equal to the remainder ( bx = 0 )
[ 510]        :                                       		; If is coeficient multiplication is below than the remainder ( bx = 1 ), increase the coeficient by one and try again
[ 511]        :                                       		; until the coeficient multiplication * divisor is above or equal to the remainder
[ 512]    0432: 83 FB 00                              		cmp bx, 0
[ 513]    0435: 74 0B                                 		je updateRemainderAndQuotient         		        	        		
[ 514]        :                                       		
[ 515]        :                                       		; Second
[ 516]        :                                       		; Stop after 9 was processed has a possible coeficient.
[ 517]        :                                       		; When this happens, the inc below will overflow coeficient by one. We'll fix it a couple lines below
[ 518]    0437: 80 3E 64 00 09                        		cmp coeficient, 9
[ 519]    043C: FE 06 64 00                           		inc coeficient        		        	
[ 520]    0440: 76 C1                                 		jbe findDivisorCoeficient
[ 521]        :                                       	
[ 522]        :                                       	        ; coeficient overflows by one (to 10). Maximum number of coeficient is 9. This because we're using the decimal numebr system nerd
[ 523]        :                                       	        ; dec coeficient	; correct overflow of coeficient
[ 524]        :                                       	
[ 525]        :                                       	
[ 526]    0442:                                       	updateRemainderAndQuotient:
[ 527]        :                                       		
[ 528]    0442: FE 0E 64 00                           		dec coeficient
[ 529]        :                                       		
[ 530]        :                                       		; increase current quotient by 1 order of magnitude (multiplication by 10)
[ 531]    0446: B9 07 00                              		mov cx, length - 1	; preform one less shift, because that one last shift would pull data from outside the array memory space				
[ 532]    0449: BE 65 00                              		lea si, quotient	
[ 533]        :                                       	
[ 534]    044C:                                       	leftShiftRemainderDiv:		; increase every digit by a order of magnitude
[ 535]    044C: 8A 44 01                              			mov al, [si + 1]	; get the digit at the right of the current position
[ 536]    044F: 88 04                                 			mov [si], al            ; override current digit with the one at it's right
[ 537]    0451: 46                                    			inc si			; move si into the next lower significance digit
[ 538]    0452: E2 F8                                 			loop leftShiftRemainderDiv	; repeat for remaining digits
[ 539]        :                                       	
[ 540]        :                                       	; add the units value to the quotient
[ 541]    0454: A0 64 00                              	mov al, coeficient
[ 542]    0457: 88 04                                 	mov [si], al
[ 543]        :                                       	
[ 544]    0459: BE 1A 00                              	lea si, result		
[ 545]    045C: E8 8A 02                              	call zeroNumber		; reset result array
[ 546]        :                                       	        	
[ 547]        :                                       	; update remainder
[ 548]        :                                       	
[ 549]    045F: BF 75 00                              	lea di, tmp6 + length - 1
[ 550]    0462: A0 64 00                              	mov al, coeficient		; mov coeficient into intermediary register
[ 551]    0465: 88 05                                 		mov [di], al
[ 552]    0467: B0 00                                 		mov al, 0
[ 553]    0469: BF 6E 00                              	lea di, tmp6
[ 554]    046C: 89 3E 35 00                           	mov mem1, di
[ 555]        :                                       	
[ 556]        :                                       	; copy divisor into tmp6, and use tmp as second operand for multiplication        	
[ 557]    0470: BE 2D 00                              	lea si, numberTwo	; copy from divisor
[ 558]    0473: BF 76 00                              	lea di, tmp7 		; copy to discartable array (value in this array will be zeroed)
[ 559]    0476: B9 08 00                              	mov cx, length		; result
[ 560]    0479: E8 F7 01                              	call copyArray        	
[ 561]    047C: BF 76 00                              	lea di, tmp7
[ 562]    047F: 89 3E 37 00                           	mov mem2, di            ; use tmp array, (because subNumber decrements)
[ 563]        :                                       	
[ 564]    0483: BF 1A 00                              	lea di, result
[ 565]    0486: 89 3E 23 00                           		mov mem3, di
[ 566]        :                                       		       	
[ 567]    048A: E8 53 00                              	call mulDiv
[ 568]        :                                       	
[ 569]    048D: BE 1A 00                              	lea si, result		; copy from
[ 570]    0490: BF 7E 00                              	lea di, tmp4		; copy to
[ 571]    0493: B9 08 00                              	mov cx, length		; result
[ 572]    0496: E8 DA 01                              	call copyArray
[ 573]        :                                       	
[ 574]    0499: BE 5C 00                              	lea si, remainder
[ 575]    049C: BF 7E 00                              	lea di, tmp4
[ 576]    049F: BB 1A 00                              		lea bx, result       	
[ 577]    04A2: E8 0D 01                              	call subNumbersMul
[ 578]        :                                       	
[ 579]    04A5: BE 1A 00                              	lea si, result		; copy from
[ 580]    04A8: BF 5C 00                              	lea di, remainder	; copy to
[ 581]    04AB: B9 08 00                              	mov cx, length		; result
[ 582]    04AE: E8 C2 01                              	call copyArray        	
[ 583]        :                                       	
[ 584]    04B1: 8A 16 6D 00                           	mov dl, dividendPointer ; dividend pointer
[ 585]    04B5: 80 FA 07                              	cmp dl, length - 1	; stop when the dividen pointer value reached the lengt of the dividend
[ 586]    04B8: FE 06 6D 00                           	inc dividendPointer
[ 587]    04BC: 73 03 E9 02 FF                        	jb updateRemainder     ; do another iteration
[ 588]        :                                       		
[ 589]    04C1:                                       		divisionFinished:      	
[ 590]        :                                       	
[ 591]    04C1: BE 65 00                              	lea si, quotient	; copy from result
[ 592]    04C4: BF 1A 00                              	lea di, result		; copy to quotient
[ 593]    04C7: B9 08 00                              	mov cx, length		; result
[ 594]    04CA: E8 A6 01                              	call copyArray
[ 595]        :                                       	
[ 596]        :                                       	; the is a bug in the division algorithm the quotient come 1 unit short every time
[ 597]        :                                       		; instead of finding and fixing the issue, we'll just add 1 to the quotient
[ 598]        :                                       		
[ 599]    04CD: BF 4B 00                              	lea di, tmp2 + length - 1	; setup array as number 1
[ 600]    04D0: C6 05 01                              	mov [di], 1               	; move 1 into units position         	
[ 601]    04D3: BE 1A 00                              lea si, result
[ 602]    04D6: BF 44 00                              	lea di, tmp2	; array representing number 1
[ 603]    04D9: BB 1A 00                              	lea bx, result
[ 604]    04DC: E8 69 01                              	call addNumbers
[ 605]        :                                       	
[ 606]    04DF: C3                                    ret
[ 607]        :                                       integerDivision endp
[ 608]        :                                       
[ 609]    04E0:                                       mulDiv proc	
[ 610]        :                                       	
[ 611]        :                                       	; Multiplication is implemented by adding the same number a bunch of times
[ 612]        :                                       	; 2 * 3, is done by adding the number 2, 3 times.
[ 613]        :                                       	; 2 * 3 = ( ( ( 0 + 2 = 2 ) + 2 = 4 ) + 2 = 6 )
[ 614]        :                                       	; The zero is the begining state of the result, when the additions are complete,
[ 615]        :                                       	; the result variable already contains the value.
[ 616]        :                                       	; The number of times the addition happens is the value of the second operand (passed in tmp3)
[ 617]        :                                       	; on each iteration, we subtract that value by 1.
[ 618]        :                                       	; We preform this while the second operand is different from zero
[ 619]        :                                       	
[ 620]        :                                       	; input
[ 621]        :                                       	; mem1, address of the first element of the array representing the first operand
[ 622]        :                                       	; mem2, address of the first element of the array representing the second operand
[ 623]        :                                       	; mem3, address of the result array
[ 624]        :                                       		
[ 625]        :                                       	; this is a destructive procedure. The second operand will be changed, and because of such,
[ 626]        :                                       	; before the algorithm starts, the second operand will be copied to tmp5 and will use that instead.
[ 627]        :                                       	
[ 628]        :                                       	; tmp1 used to save the consecutive additions on each iteration
[ 629]        :                                       	; tmp2 used to represent the number 1 to subtract the divisor on each iteration
[ 630]        :                                       	; tmp3 contains the remainign additions left to complete the multiplication
[ 631]        :                                       	; tmp5 second operand is copied into a discartable
[ 632]        :                                       	
[ 633]        :                                       	; backup second operand in tmp5 array
[ 634]    04E0: 8B 1E 37 00                           	mov bx, mem2		; reference mem2 (memory address of second operand)
[ 635]    04E4: 8D 37                                 	lea si, [bx]		; indirectly reference mem2 value
[ 636]    04E6: BF 54 00                              	lea di, tmp5		; copy second operand into discartable array
[ 637]    04E9: B9 08 00                              	mov cx, length
[ 638]    04EC: E8 84 01                              call copyArray		; copy from array in si to array in di
[ 639]        :                                       	
[ 640]    04EF:                                       	additionCycleMulDiv:
[ 641]        :                                       	     	 				
[ 642]        :                                       		
[ 643]        :                                       		; validate if we have any addition to preform , input di register		 		
[ 644]    04EF: BF 54 00                              		lea di, tmp5		; number of additions left to preform
[ 645]    04F2: E8 AA 00                              		call arrayIsZero	; validate
[ 646]    04F5: 83 FA 00                              		cmp dx, 0
[ 647]    04F8: 74 5B                                 		je mulCompleteMulDiv	; if zero, no addition remains. Exit the addition loop
[ 648]        :                                       		
[ 649]        :                                       		; load input variables into apropriate register
[ 650]    04FA: 8B 1E 35 00                           		mov bx, mem1		; reference mem1 (first operand array memory address)
[ 651]    04FE: 8D 37                                 		lea si, [bx]		; indirectly reference mem1 value     							
[ 652]    0500: 8B 1E 23 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 653]    0504: 8D 1F                                 		lea bx, [bx]		; indirectly reference mem3 value		                                                                           	
[ 654]        :                                       		
[ 655]        :                                       		; Access the result from the previous iteration (in tmp1) and store it in the result. If it's the first iteration, tmp1 array is all zeros
[ 656]    0506: BE 3C 00                              		lea si, tmp1		; copy value from previous iteration
[ 657]    0509: 8B 1E 23 00                           		mov bx, mem3		; into reference memory mem3 (result variable array memory address)
[ 658]    050D: 8D 3F                                 		lea di, [bx]		; indirectly reference mem3
[ 659]    050F: B9 08 00                              		mov cx, length
[ 660]    0512: E8 5E 01                              		call copyArray		; execute copy
[ 661]        :                                       
[ 662]        :                                       		; preform one addition		
[ 663]    0515: 8B 1E 35 00                           		mov bx, mem1		; reference mem1 (first operand array memory address)
[ 664]    0519: 8D 37                                 		lea si, [bx]		; indirectly reference mem1 value
[ 665]    051B: 8B 1E 23 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 666]    051F: 8D 3F                                 		lea di, [bx]		; indirectly reference mem3 value		
[ 667]    0521: E8 24 01                              		call addNumbers		; execute addition
[ 668]        :                                       		
[ 669]        :                                       		; save result for the next iteration. Subtraction will override the result variable
[ 670]    0524: 8B 1E 23 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 671]    0528: 8D 37                                 		lea si, [bx]
[ 672]    052A: BF 3C 00                              		lea di, tmp1		; save the result for next interation
[ 673]    052D: B9 08 00                              		mov cx, length
[ 674]    0530: E8 40 01                              		call copyArray		
[ 675]        :                                       				
[ 676]    0533: BE 54 00                              		lea si, tmp5		;
[ 677]    0536: C6 06 4B 00 01                        		mov [tmp2 + length - 1], 1	; setup array representing number 1		
[ 678]    053B: BF 44 00                              		lea di, tmp2		; load array memory address for subtraction	
[ 679]    053E: 8B 1E 23 00                           		mov bx, mem3		; reference mem3 (result variable array memory address)
[ 680]    0542: 8D 1F                                 		lea bx, [bx]
[ 681]    0544: E8 6B 00                              		call subNumbersMul	; execute subtraction
[ 682]        :                                       		
[ 683]        :                                       		; subtraction saved the result in the result variable
[ 684]        :                                       		; for the algorithm, the numberTwo itself needs to be
[ 685]        :                                       		; the one decremented, so we're going to copy the value
[ 686]        :                                       		; from result to numberTwo
[ 687]        :                                       		
[ 688]    0547: BE 1A 00                              		lea si, result		
[ 689]    054A: BF 54 00                              		lea di, tmp5
[ 690]    054D: B9 08 00                              		mov cx, length
[ 691]    0550: E8 20 01                              		call copyArray
[ 692]        :                                       		
[ 693]    0553: EB 9A                                 		jmp additionCycleMulDiv	
[ 694]        :                                       	
[ 695]    0555:                                       	mulCompleteMulDiv:
[ 696]        :                                       	
[ 697]    0555: BE 3C 00                              	lea si, tmp1
[ 698]    0558: 8B 1E 23 00                           	mov bx, mem3		
[ 699]    055C: 8D 3F                                 	lea di, [bx]
[ 700]    055E: B9 08 00                              	mov cx, length
[ 701]    0561: E8 0F 01                              	call copyArray
[ 702]        :                                       	
[ 703]        :                                       	; zero out accumulator array
[ 704]    0564: BE 3C 00                              	lea si, tmp1
[ 705]    0567: E8 7F 01                              	call zeroNumber
[ 706]        :                                       	
[ 707]        :                                       	; zero out subtraction tmp array
[ 708]    056A: BE 4B 00                              	lea si, tmp2 + length - 1
[ 709]    056D: C6 04 00                              	mov [si], 0	
[ 710]        :                                       	
[ 711]    0570: C3                                    	ret
[ 712]        :                                       mulDiv endp
[ 713]        :                                       
[ 714]    0571:                                       mulSetup proc
[ 715]        :                                       
[ 716]    0571: BE 25 00                              	lea si, numberOne
[ 717]    0574: 89 36 35 00                           	mov mem1, si
[ 718]        :                                       	
[ 719]    0578: BF 2D 00                              	lea di, numberTwo
[ 720]    057B: 89 3E 37 00                           	mov mem2, di
[ 721]        :                                       	
[ 722]    057F: BB 1A 00                              	lea bx, result
[ 723]    0582: 89 1E 23 00                           	mov mem3, bx	   	
[ 724]        :                                       	
[ 725]    0586: E8 57 FF                              	call mulDiv
[ 726]        :                                       
[ 727]    0589: C3                                    	ret
[ 728]        :                                       mulSetup endp
[ 729]        :                                       
[ 730]    058A:                                       lengthOfNumber proc
[ 731]        :                                       
[ 732]        :                                       ; this procedure counts the number of significant digits in the array (does not count leading zeros)
[ 733]        :                                       
[ 734]        :                                       ; input: si points to the array
[ 735]        :                                       ; output: dx will contains the number of digits of the number
[ 736]        :                                       
[ 737]    058A: B9 00 00                              mov cx, 0
[ 738]    058D: B1 08                                 	mov cl, length
[ 739]    058F: BA 00 00                              	mov dx, 0
[ 740]        :                                       	
[ 741]    0592:                                       	countDigitsOfNumber:
[ 742]        :                                       	
[ 743]    0592: 80 3C 00                              		cmp [si], 0
[ 744]    0595: 75 03                                 		jne notLeadingZero
[ 745]        :                                       	
[ 746]    0597: 46                                    	        inc si
[ 747]        :                                       	
[ 748]    0598: E2 F8                                 		loop countDigitsOfNumber
[ 749]        :                                       		
[ 750]    059A:                                       		notLeadingZero:
[ 751]    059A: B2 08                                 		mov dl, length
[ 752]    059C: 2A D1                                 		sub dl, cl
[ 753]        :                                       		
[ 754]    059E: C3                                    	ret
[ 755]        :                                       
[ 756]        :                                       lengthOfNumber endp
[ 757]        :                                       
[ 758]    059F:                                       arrayIsZero proc
[ 759]        :                                       	; compares each digit to zero
[ 760]        :                                       	; if every single one of them is zero, at the end
[ 761]        :                                       	; dx will contain a 0, otherwise, dx will contain a 1
[ 762]        :                                       	
[ 763]        :                                       	; input data:
[ 764]        :                                       	; di : points to the start of the number array
[ 765]        :                                       	
[ 766]        :                                       	; output data:   	
[ 767]        :                                       	; dx : output ( 0 : array represents a zero number  |  1 : array represents a non-zero number )
[ 768]        :                                       	
[ 769]    059F: BA 00 00                              	mov dx, 0
[ 770]    05A2: B9 08 00                              	mov cx, length
[ 771]        :                                       	
[ 772]    05A5:                                       	validate:
[ 773]    05A5: 80 3D 00                              		cmp [di], 0	; compare digit to zero
[ 774]    05A8: 75 04                                 		jne notZero	; if the digit in not a zero, exit the loop and mark the flag as 1 ( 1: array is a non-zero number)
[ 775]        :                                       	
[ 776]    05AA: 47                                    	        inc di		; move to next digit
[ 777]        :                                       		
[ 778]    05AB: E2 F8                                 		loop validate	
[ 779]        :                                       	
[ 780]    05AD: C3                                    	ret
[ 781]        :                                       		
[ 782]    05AE:                                       	notZero:
[ 783]    05AE: BA 01 00                              	mov dx, 1    	
[ 784]    05B1: C3                                    	ret
[ 785]        :                                       arrayIsZero endp
[ 786]        :                                       
[ 787]    05B2:                                       subNumbersMul proc
[ 788]        :                                       						
[ 789]    05B2: F8                                    	clc		; Clear Carry Flag (cf = 0)
[ 790]    05B3: B8 00 00                              	mov ax, 0	; clear ax
[ 791]        :                                       	
[ 792]    05B6: 83 C6 07                              	add si, length - 1	; put si in the memory address of the last element of the numerOne array
[ 793]    05B9: 83 C7 07                              	add di, length - 1	; put di in the memory address of the last element of the numerTwo array
[ 794]    05BC: 80 C3 07                              	add bl, length - 1	; put bx in the memory address of the last element of the result array	
[ 795]        :                                       
[ 796]    05BF: B9 08 00                              	mov cx, length	
[ 797]        :                                       		
[ 798]    05C2:                                       	subElementsMul:	
[ 799]    05C2: 8A 04                                 		mov al, [si]
[ 800]    05C4: 3A 05                                 		cmp al, [di]
[ 801]    05C6: 73 11                                 		jae subDontSetCarryMul
[ 802]        :                                       			
[ 803]    05C8: 04 0A                                 		add al, 10	; minuend below subtrahend, so add the to the minuend ; this add overrides the default carry flag. bugs out the sbb operations below		
[ 804]        :                                       		
[ 805]    05CA:                                       		subSetCarryMul:	
[ 806]    05CA: 2A 05                                 		sub al, [di]			; subtract values and carry
[ 807]    05CC: 2A 06 3A 00                           		sub al, anotherCarryFlag	; subtract the carry from the previous subtraction
[ 808]    05D0: C6 06 3A 00 01                        		mov anotherCarryFlag, 1		; set carry flag for subtraction
[ 809]    05D5: 88 07                                 		mov [bx], al			; move the subtraction result to the corresponding element of the result array
[ 810]    05D7: EB 0D                                 		jmp subContinueMul
[ 811]        :                                       		
[ 812]    05D9:                                       		subDontSetCarryMul:
[ 813]    05D9: 2A 05                                 		sub al, [di]			; move the subtraction result to the corresponding element of the result array
[ 814]    05DB: 2A 06 3A 00                           		sub al, anotherCarryFlag	; subtract the carry from the previous subtraction
[ 815]    05DF: C6 06 3A 00 00                        		mov anotherCarryFlag, 0		; clear carry flag for subtraction
[ 816]    05E4: 88 07                                 		mov [bx], al			; move the subtraction result to the corresponding element of the result array
[ 817]        :                                       		
[ 818]        :                                       		
[ 819]    05E6:                                       		subContinueMul:
[ 820]    05E6: 4E                                    		dec si		; move si pointer to the left element of the array (one order greater)
[ 821]    05E7: 4F                                    		dec di		; move di pointer to the left element of the array (one order greater)
[ 822]    05E8: 4B                                    		dec bx		; move bx pointer to the left element of the array (one order greater)
[ 823]    05E9: B0 00                                 		mov al, 0	; clear ax for following operations
[ 824]        :                                       	
[ 825]    05EB: E2 D5                                 loop subElementsMul
[ 826]        :                                       			       	
[ 827]    05ED: C3                                    	ret	
[ 828]        :                                       subNumbersMul endp
[ 829]        :                                       
[ 830]    05EE:                                       subNumbers proc
[ 831]        :                                       	; TODO write some bs about how the algorithm requires a positive result
[ 832]        :                                       	; TODO the minuend as to be greater or equal to the subtrahend explain that
[ 833]        :                                       	; TODO yeah also describe the subtraction algorithm
[ 834]        :                                       	
[ 835]        :                                       	; How to deal with negative results.
[ 836]        :                                       	; Subtraction is not a commutative operation, but there is a direct relation in the result if we swap the operands.
[ 837]        :                                       	; If we swap the operands, the result is going to have the same absolute value, but the symmetric sign.
[ 838]        :                                       	; The sign of the the result can be predicted by the order of the operands
[ 839]        :                                       	; if the minuend is below the subtrahend, we're facing a negative result
[ 840]        :                                       	; Knowing both this things, we will predict when the subtraction would result in a signed negative value and react accordingly
[ 841]        :                                       	; If the result is negative, we will swap the operands resulting in a signed positive and set a flag to represent the result is unsigned negative
[ 842]        :                                       	
[ 843]    05EE: BE 25 00                              	lea si, numberOne 	; put si in the memory address of the fist element of the numerOne array
[ 844]    05F1: BF 2D 00                              	lea di, numberTwo	; put di in the memory address of the fist element of the numerTwo array
[ 845]        :                                       	
[ 846]    05F4: E8 95 00                              	call determineSubtractionSign	; signed subtraction is not suported. We will predict the sign of the result and if it's negative swap the operands
[ 847]        :                                       	
[ 848]    05F7: 83 FB 00                              	cmp bx, 0
[ 849]    05FA: 74 10                                 	je skipOperandSwap
[ 850]        :                                       	
[ 851]        :                                       	; to not deal with a negative result, we will swap the operands and have a flag representing a negative result 	
[ 852]    05FC: 88 1E 22 00                           	mov resultSign, bl	; set negative number flag
[ 853]        :                                       	
[ 854]    0600: B9 08 00                              	mov cx, length
[ 855]    0603: BE 25 00                              	lea si, numberOne
[ 856]    0606: BF 2D 00                              	lea di, numberTwo
[ 857]        :                                       	
[ 858]    0609: E8 73 00                              	call swapDigitsBetweenNumbers			
[ 859]        :                                       		
[ 860]    060C:                                       	skipOperandSwap:
[ 861]    060C: F8                                    	clc		; Clear Carry Flag (cf = 0)
[ 862]    060D: B8 00 00                              	mov ax, 0	; clear ax
[ 863]        :                                       	
[ 864]    0610: BE 2C 00                              	lea si, numberOne + length - 1	; put si in the memory address of the last element of the numerOne array
[ 865]    0613: BF 34 00                              	lea di, numberTwo + length - 1  ; put di in the memory address of the last element of the numerTwo array
[ 866]    0616: BB 21 00                              	lea bx, result + length - 1	; put bx in the memory address of the last element of the result array	
[ 867]        :                                       	
[ 868]    0619: B9 08 00                              	mov cx, length	; loop should repeat for the size of the array
[ 869]        :                                       	
[ 870]    061C:                                       	subElements:		
[ 871]        :                                       		; To deal with negative results on each iteration, we're going to avoid them alltogether.
[ 872]        :                                       		; Negative results in subtraction happen when we subtract a digit by a larger one, so
[ 873]        :                                       		; we're going to validate if the minuend digit is below the subtrahend digit and if so
[ 874]        :                                       		; add 10 to the minuend value, set a carry flag for later and then preform the subtraction
[ 875]        :                                       		; The carry flag will be subtracted to the minuend in the following iteration
[ 876]        :                                       		
[ 877]    061C: 8A 04                                 		mov al, [si]
[ 878]    061E: 3A 05                                 		cmp al, [di]
[ 879]    0620: 73 11                                 		jae subDontSetCarry
[ 880]        :                                       		
[ 881]    0622: 04 0A                                 		add al, 10	; minuend below subtrahend, so add the to the minuend ; this add overrides the default carry flag. bugs out the sbb operations below		
[ 882]        :                                       	
[ 883]    0624:                                       		subSetCarry:	
[ 884]    0624: 2A 05                                 		sub al, [di]			; subtract values and carry
[ 885]    0626: 2A 06 3A 00                           		sub al, anotherCarryFlag	; subtract the carry from the previous subtraction
[ 886]    062A: C6 06 3A 00 01                        		mov anotherCarryFlag, 1		; set carry flag for subtraction
[ 887]    062F: 88 07                                 	        mov [bx], al			; move the subtraction result to the corresponding element of the result array
[ 888]    0631: EB 0D                                 	        jmp subContinue
[ 889]        :                                       	
[ 890]    0633:                                       	        subDontSetCarry:
[ 891]    0633: 2A 05                                 	        sub al, [di]			; move the subtraction result to the corresponding element of the result array
[ 892]    0635: 2A 06 3A 00                           	        sub al, anotherCarryFlag        ; subtract the carry from the previous subtraction
[ 893]    0639: C6 06 3A 00 00                        	        mov anotherCarryFlag, 0		; clear carry flag for subtraction
[ 894]    063E: 88 07                                 	        mov [bx], al			; move the subtraction result to the corresponding element of the result array
[ 895]        :                                       	
[ 896]        :                                       	
[ 897]    0640:                                       	        subContinue:
[ 898]    0640: 4E                                    	        dec si		; move si pointer to the left element of the array (one order greater)
[ 899]    0641: 4F                                    	        dec di  	; move di pointer to the left element of the array (one order greater)
[ 900]    0642: 4B                                    	        dec bx  	; move bx pointer to the left element of the array (one order greater)
[ 901]    0643: B0 00                                 	        mov al, 0	; clear ax for following operations
[ 902]        :                                       	
[ 903]    0645: E2 D5                                 		loop subElements			       	
[ 904]    0647: C3                                    	ret	
[ 905]        :                                       subNumbers endp
[ 906]        :                                       
[ 907]    0648:                                       addNumbers proc
[ 908]        :                                       	
[ 909]    0648: F8                                    	clc		; Clear Carry Flag (cf = 0)
[ 910]    0649: B8 00 00                              	mov ax, 0	; clear ax
[ 911]        :                                       	
[ 912]    064C: 83 C6 07                              	add si, length - 1		; put si in the memory address of the last element of the first array
[ 913]    064F: 83 C7 07                              	add di, length - 1  		; put di in the memory address of the last element of the second array
[ 914]    0652: BB 21 00                              	lea bx, result + length - 1	; put bx in the memory address of the last element of the result array	
[ 915]        :                                       	
[ 916]    0655: B9 08 00                              	mov cx, length	; loop should repeat for the size of the array
[ 917]        :                                       	
[ 918]    0658:                                       	addElements:
[ 919]    0658: 8A 04                                 		mov al, [si]	; add a digit of first number
[ 920]    065A: 12 05                                 		adc al, [di]    ; add a digit of first number
[ 921]        :                                       	
[ 922]    065C: 3C 0A                                 	        cmp al, 10      ; check if the result is greater than or equal to 10
[ 923]    065E: 72 07                                 		jb no_carry     ; if not, skip carry adjustment
[ 924]        :                                       		
[ 925]    0660:                                       		carry:	
[ 926]    0660: 2C 0A                                 		sub al, 10      ; adjust the result to fit in a single decimal digit
[ 927]    0662: F9                                    		stc             ; SeT Carry Flag (cf = 1)
[ 928]    0663: 88 07                                 	        mov [bx], al    ; move the sum to the corresponding element of the result array
[ 929]    0665: EB 03                                 	        jmp continue
[ 930]        :                                       	
[ 931]    0667:                                       	        no_carry:
[ 932]    0667: F8                                    	        clc             ; Clear Carry Flag (cf = 0)
[ 933]    0668: 88 07                                 	        mov [bx], al    ; move the sum to the corresponding element of the result array
[ 934]        :                                       	
[ 935]    066A:                                       	        continue:
[ 936]    066A: 4E                                    	        dec si		; move si pointer to the left element of the array (one order greater)
[ 937]    066B: 4F                                    	        dec di 		; move di pointer to the left element of the array (one order greater)
[ 938]    066C: 4B                                    	        dec bx  	; move bx pointer to the left element of the array (one order greater)
[ 939]    066D: B8 00 00                              	        mov ax, 0	; clear ax for following operations
[ 940]        :                                       	
[ 941]    0670: E2 E6                                 		loop addElements
[ 942]        :                                       	
[ 943]    0672: C3                                    	ret	
[ 944]        :                                       addNumbers endp
[ 945]        :                                       
[ 946]        :                                       
[ 947]    0673:                                       copyArray proc
[ 948]        :                                       
[ 949]        :                                       	; si : array to copy values from
[ 950]        :                                       	; di : array to copy values to	
[ 951]        :                                       	; deprecated; cx : length of the arrays
[ 952]    0673: B9 08 00                              	mov cx, length
[ 953]        :                                       	
[ 954]    0676:                                       	doCopy:
[ 955]    0676: 8A 04                                 		mov al, [si]
[ 956]    0678: 88 05                                 		mov [di], al
[ 957]        :                                       		
[ 958]    067A: 46                                    		inc si
[ 959]    067B: 47                                    		inc di
[ 960]        :                                       		
[ 961]    067C: E2 F8                                 		loop doCopy		
[ 962]    067E: C3                                    	ret
[ 963]        :                                       copyArray endp
[ 964]        :                                       
[ 965]    067F:                                       swapDigitsBetweenNumbers proc
[ 966]        :                                       
[ 967]        :                                       	; swap array specified by si and di register
[ 968]        :                                       	; cx must contain the length of the arrays
[ 969]        :                                       
[ 970]    067F:                                       	doSwap:
[ 971]    067F: 8A 04                                 		mov al, [si]
[ 972]    0681: 8A 1D                                 		mov bl, [di]
[ 973]    0683: 88 1C                                 		mov [si], bl
[ 974]    0685: 88 05                                 		mov [di], al
[ 975]    0687: 46                                    		inc si
[ 976]    0688: 47                                    		inc di
[ 977]    0689: E2 F4                                 		loop doSwap
[ 978]        :                                       		
[ 979]    068B: C3                                    	ret		
[ 980]        :                                       swapDigitsBetweenNumbers endp
[ 981]        :                                       
[ 982]    068C:                                       determineSubtractionSign proc
[ 983]        :                                       
[ 984]        :                                       ; compare arrays in SI and DI
[ 985]        :                                       
[ 986]        :                                       ; on procedure end, SI and DI are not within their initial array bounds
[ 987]        :                                       
[ 988]    068C: B8 00 00                              mov ax, 0		; zero register
[ 989]    068F: BB 00 00                              mov bx, 0		; bx contains the subtraction result sign (0 positive or zero result, 1 negative result)  	
[ 990]        :                                       	
[ 991]    0692: B9 08 00                              mov cx, length		; preform the validation for each digit. The amount of digits in a number is specified by length
[ 992]        :                                       
[ 993]    0695:                                       compareDigitsToValidateSubtraction:
[ 994]        :                                       	; to validate if the number in si is above or equal to the number in di. Numbers are arrays of the same length.
[ 995]        :                                       	; we're going to validate if each digit of number1 is above or equal to the corresponding magnitude digit of number2.
[ 996]        :                                       	; When the validation fails, up to that point the number1 digits are either above or equal to the digits of number2,
[ 997]        :                                       	; and on the moment the validation fails, the number2 is above of number1
[ 998]        :                                       	; we will stop here and mark the flag (bx) as 1 (negative)
[ 999]        :                                       	
[1000]        :                                       		; cmp [si], [di] error. CMP cannot take both operands to be memory references
[1001]        :                                       		
[1002]    0695: 8A 05                                 		mov al, [di]
[1003]    0697: 38 04                                 		cmp [si], al
[1004]    0699: 77 06                                 		ja positiveResultDetected	; number1 digit must be above to the corresponding magnitude digit of number2 to result positive
[1005]        :                                       	 	
[1006]    069B: 74 08                                 	 	je compareNextDigits            ; if digits are equal, the result will be determined through the remainding less significative digits
[1007]        :                                       	 	
[1008]    069D:                                       		negativeResultDetected:
[1009]    069D: BB 01 00                              		mov bx, 1	; validation flag contains subtraction result sign (0 positive result, 1 negative result)		 		 		
[1010]    06A0: C3                                    		ret		; no point continuing the validation for the remaining digits.
[1011]        :                                       		
[1012]    06A1:                                       		positiveResultDetected:
[1013]    06A1: BB 00 00                              		mov bx, 0	; validation flag contains subtraction result sign (0 positive result, 1 negative result)		 		 		
[1014]    06A4: C3                                    		ret		; no point continuing the validation for the remaining digits.
[1015]        :                                       		                      		
[1016]    06A5:                                       		compareNextDigits:
[1017]    06A5: 46                                    		inc si
[1018]    06A6: 47                                    		inc di
[1019]        :                                       		 		
[1020]    06A7: E2 EC                                 		loop compareDigitsToValidateSubtraction
[1021]        :                                       		
[1022]        :                                       		; if reached here, subtraction results is zero
[1023]        :                                       		
[1024]    06A9: BB 00 00                              		mov bx, 0
[1025]        :                                       		
[1026]    06AC: C3                                    	ret
[1027]        :                                       determineSubtractionSign endp
[1028]        :                                       
[1029]    06AD:                                       outputResult PROC	
[1030]        :                                       	
[1031]    06AD: BA 08 00                              	lea dx, resultPreText	; move output prefix text
[1032]    06B0: B4 09                                 	mov ah, 09h	; load function to print out sting in DX
[1033]    06B2: CD 21                                 	int 21h         ; execute 09h                                                           	
[1034]        :                                       	
[1035]        :                                       	; The output procedure validates for leading zeros and if it's a leading zero, it does not print it
[1036]        :                                       	; The issue is, if no validation is preformed, for the number zero, nothing will be printed
[1037]        :                                       	; this because the the leading zero validation uses any number different to zero
[1038]        :                                       	; since zero does not contain any non-zero number, every digit of the array will be considered a leading zero and nothing will get printed
[1039]        :                                       	; To fix this issue, the print loop will not print the last digit (meaning it will not reform the leading zero on the last digit)
[1040]        :                                       	; then we will manually print the last digit (without validating for a leading zero).
[1041]        :                                       	; Like this, we assure when printing number 0 that a leading zero bug does not occour.
[1042]        :                                       	
[1043]    06B4: B9 07 00                              	mov cx, length 	- 1	; loop over every digit minus the least significant digit
[1044]    06B7: BE 1A 00                              	lea si, result  ; point into the beggining result array	
[1045]        :                                       	
[1046]    06BA:                                       	outputSignValidation:
[1047]    06BA: 80 3E 22 00 01                        	cmp resultSign, 1	; (0 = positive number, 1 = negative number)
[1048]    06BF: 75 03                                 	jne outputDigit
[1049]        :                                       	
[1050]    06C1: E8 24 01                              	call outputMinusChar	
[1051]        :                                       	
[1052]    06C4:                                       	outputDigit:
[1053]        :                                       		; process each digit on each iteration
[1054]        :                                       		; validate for leading zero and print if it isn't a leading zero
[1055]        :                                       		; todo the next line is moving a value into dh. why? si shouldn't point to a dw var? I can't be bothered to check right now. Future you, do that
[1056]    06C4: 8B 14                                 	    	mov dx, [si]	; Move digit from result into dx for processing
[1057]    06C6: 80 FA 00                              	    	cmp dl, 0	; Compare the digit with zero
[1058]    06C9: 74 05                                 	    	je checkZero	; If zero, check if it can be ignored as a leading zero
[1059]        :                                       	    	
[1060]    06CB: BB 01 00                              	    	mov bx, 1	; Found a non-zero digit, enable leading zero flag
[1061]    06CE: EB 05                                 	    	jmp printDigit	; Jump to printing the digit
[1062]        :                                       	
[1063]    06D0:                                       	checkZero:
[1064]    06D0: 83 FB 01                              	    	cmp bx, 1	; Check if the leading zero flag is enabled
[1065]    06D3: 75 07                                 	    	jne skipDigit	; If not enabled, skip this zero
[1066]        :                                       	
[1067]    06D5:                                       	printDigit:
[1068]    06D5: 83 C2 30                              	    	add dx, 48	; Convert number into ASCII character
[1069]    06D8: B4 02                                 	    	mov ah, 02h	; Load function to print out digit in DX
[1070]    06DA: CD 21                                 	    	int 21h		; Execute
[1071]        :                                       	
[1072]    06DC:                                       	skipDigit:
[1073]    06DC: 46                                    	    	inc si		; Move to the next digit
[1074]    06DD: E2 E5                                 	    	loop outputDigit; Repeat for the next digit
[1075]        :                                       	
[1076]        :                                       	; manually print the last digit
[1077]    06DF: 8B 14                                 	mov dx, [si]    	
[1078]    06E1: 83 C2 30                              	add dx, 48	; Convert number into ASCII character
[1079]    06E4: B4 02                                 	mov ah, 02h	; Load function to print out digit in DX
[1080]    06E6: CD 21                                 	int 21h		; Execute
[1081]        :                                       	
[1082]    06E8: C3                                    	ret
[1083]        :                                       outputResult ENDP
[1084]        :                                       
[1085]        :                                       
[1086]    06E9:                                       zeroNumber proc
[1087]        :                                       	
[1088]        :                                       	; input: number to reset is defined by the addresss in si
[1089]        :                                       	; after function: si register points to the start of the array
[1090]        :                                       	
[1091]    06E9: B9 08 00                              	mov cx, length
[1092]        :                                       	
[1093]        :                                       	; si points to the biggining of the array
[1094]        :                                       	
[1095]    06EC:                                       	zeroDigit:
[1096]    06EC: C6 04 00                              		mov [si], 0
[1097]    06EF: 46                                    		inc si
[1098]    06F0: E2 FA                                 		loop zeroDigit
[1099]        :                                       	
[1100]        :                                       	; WARNING: do not add -1 to length. The previous loop makes si overflow the array by one position
[1101]        :                                       	; and therefore, subtracting si by length returns to the first element of the array
[1102]    06F2: 83 EE 08                              	sub si, length	
[1103]        :                                       			
[1104]    06F5: C3                                    	ret
[1105]        :                                       zeroNumber endp
[1106]        :                                       
[1107]        :                                       
[1108]    06F6:                                       readNumberInput PROC
[1109]        :                                       	
[1110]        :                                       	; the number will be stored in an arbitrary array
[1111]        :                                       
[1112]        :                                       	; the array is defined by the address in the SI register, should be of the address of the first index in the array	   	    	
[1113]        :                                       	
[1114]    06F6: B9 08 00                              	mov cx, length	; max digits in the number	         		
[1115]        :                                       	
[1116]    06F9:                                       	readingDigit:
[1117]    06F9: B4 01                                 		mov ah, 01h	; read keyboard character function, input in AL
[1118]    06FB: CD 21                                 		int 21h
[1119]        :                                       		
[1120]    06FD: 3C 1B                                 		cmp al, 27	; escape key, exit program
[1121]    06FF: 75 03 E9 02 01                        		je exitProgram
[1122]        :                                       		
[1123]    0704: 3C 08                                 		cmp al, 8	; compare to backspace key, if so remove last digit inputed
[1124]    0706: 74 29                                 		je is_backspace
[1125]        :                                       		
[1126]    0708: 3C 0D                                 		cmp al, 13	; compare to enter key, if so number is complete and move on
[1127]    070A: 75 03 E9 99 00                        		je inputIsFinished
[1128]        :                                       	
[1129]    070F: 3C 2B                                 	        cmp al, 43	; + addition operation
[1130]    0711: 74 2F                                 	        je set_sum_operation
[1131]        :                                       	
[1132]    0713: 3C 2D                                 	        cmp al, 45	; - subtraction operation
[1133]    0715: 74 39                                 	        je set_sub_operation
[1134]        :                                       	
[1135]    0717: 3C 2A                                 	        cmp al, 42	; * multiplication operation
[1136]    0719: 74 43                                 	        je set_mul_operation
[1137]        :                                       	
[1138]    071B: 3C 2F                                 	        cmp al, 47	; / division operation
[1139]    071D: 74 4D                                 	        je set_div_operation
[1140]        :                                       	
[1141]    071F: 3C 56                                 	        cmp al, 86	; V sqrt operation
[1142]    0721: 74 57                                 	        je set_sqrt_operation
[1143]        :                                       	
[1144]    0723: 3C 76                                 	        cmp al, 118	; v sqrt operation
[1145]    0725: 74 53                                 	        je set_sqrt_operation
[1146]        :                                       	
[1147]        :                                       	        ; cmp al, 110	; n nif validation
[1148]        :                                       	        ; je set_nif_validation
[1149]        :                                       	
[1150]        :                                       	        ; cmp al, 99	; c cc validation
[1151]        :                                       	        ; je set_cc_validation
[1152]        :                                       	
[1153]        :                                       	        ; cmp al, 98	; b ean13 barcode validation
[1154]        :                                       	        ; je set_ean13_barcode_validation
[1155]        :                                       	
[1156]    0727: 3C 30                                 	   	cmp al, 48	; validate if ascii code is lower than {ascci code 48, decimal 0}, if so, not a valid number, ask digit again
[1157]    0729: 7C 5D                                 	   	jl not_a_number
[1158]        :                                       	   	
[1159]    072B: 3C 39                                 	   	cmp al, 57	; validate if ascii code is higher than {ascci code 57, decimal 9}, if so, not a valid number, ask digit again
[1160]    072D: 7F 59                                 	   	jg not_a_number
[1161]        :                                       	   	
[1162]        :                                       	   	; if reached here, input is a valid number
[1163]    072F: EB 69                                 	   	jmp is_a_validNumber
[1164]        :                                       	   		
[1165]    0731:                                       		is_backspace:	  		
[1166]    0731: 83 F9 08                              	   		cmp cx, length	; validate edge case if no number has been inputed yet
[1167]    0734: 74 07                                 	  		je invalidBackspace     			
[1168]        :                                       			
[1169]    0736: E8 A7 00                              	  		call deleteCurrentCharacter
[1170]    0739: 58                                    			pop ax	; remove the digit from the stack	  		      	  	
[1171]        :                                       	  		; loop changed to  jmp.
[1172]    073A: 41                                    	  		inc cx	; allow for another loop iteration
[1173]        :                                       	  		 	
[1174]    073B: EB BC                                 	   		jmp readingDigit	   		
[1175]        :                                       	   	
[1176]    073D:                                       	   	invalidBackspace:
[1177]    073D: E8 B0 00                              	 	  	call correctInvalidBackspace
[1178]    0740: EB B7                                 	   		jmp readingDigit
[1179]        :                                       	   	
[1180]    0742:                                       	   	set_sum_operation:
[1181]    0742: 80 3E 39 00 00                        	   		cmp operation, 0
[1182]    0747: 75 5F                                 	   		jne inputIsFinished	; operation has already been set.
[1183]        :                                       	   		
[1184]    0749: C6 06 39 00 2B                        	   		mov operation, '+'
[1185]        :                                       	   		
[1186]    074E: EB 58                                 	   		jmp inputIsFinished
[1187]        :                                       	   		
[1188]    0750:                                       	   	set_sub_operation:
[1189]    0750: 80 3E 39 00 00                        	   		cmp operation, 0
[1190]    0755: 75 51                                 	   		jne inputIsFinished	; operation has already been set.
[1191]        :                                       	   		
[1192]    0757: C6 06 39 00 2D                        	   		mov operation, '-'
[1193]        :                                       	   		
[1194]    075C: EB 4A                                 	   		jmp inputIsFinished
[1195]        :                                       	   		
[1196]    075E:                                       	   	set_mul_operation:
[1197]    075E: 80 3E 39 00 00                        	   		cmp operation, 0
[1198]    0763: 75 43                                 	   		jne inputIsFinished	; operation has already been set.
[1199]        :                                       	   		
[1200]    0765: C6 06 39 00 2A                        	   		mov operation, '*'
[1201]        :                                       	   		
[1202]    076A: EB 3C                                 	   		jmp inputIsFinished
[1203]        :                                       	   		
[1204]    076C:                                       	   	set_div_operation:
[1205]    076C: 80 3E 39 00 00                        	   		cmp operation, 0
[1206]    0771: 75 35                                 	   		jne inputIsFinished	; operation has already been set.
[1207]        :                                       	   		
[1208]    0773: C6 06 39 00 2F                        	   		mov operation, '/'
[1209]        :                                       	   		
[1210]    0778: EB 2E                                 	   		jmp inputIsFinished
[1211]        :                                       	
[1212]    077A:                                       		set_sqrt_operation:
[1213]    077A: 80 3E 39 00 00                        	   		cmp operation, 0
[1214]    077F: 75 27                                 	   		jne inputIsFinished	; operation has already been set.
[1215]        :                                       	   		
[1216]    0781: C6 06 39 00 76                        	   		mov operation, 'v'
[1217]        :                                       	   		
[1218]    0786: EB 20                                 	   		jmp inputIsFinished      	   			   		
[1219]        :                                       	   		   	
[1220]    0788:                                       	        not_a_number:
[1221]        :                                       			; you morom can't even put a valid input shame grow a tumor shame shame shame
[1222]    0788: E8 4D 00                              			call putABackspaceInTheConsoleAndDeleteThePreviousCharacter
[1223]    078B: E9 6B FF                              			jmp readingDigit	; since you put a wrong characer, you now get to do it again dumb f
[1224]        :                                       	
[1225]    078E:                                       	        numberIsOfmaxSize:
[1226]        :                                       	 		; since the number is max size no more digits can be added to it. Only a operator
[1227]    078E: E8 47 00                              	 		call putABackspaceInTheConsoleAndDeleteThePreviousCharacter
[1228]    0791: E9 65 FF                              	 		jmp readingDigit
[1229]        :                                       	 		
[1230]    0794:                                       	 	deletePrev:
[1231]        :                                       	 		; since the number is max size no more digits can be added to it. Only a operator
[1232]    0794: E8 41 00                              	 		call putABackspaceInTheConsoleAndDeleteThePreviousCharacter
[1233]    0797: E9 5F FF                              	 		jmp readingDigit
[1234]        :                                       	
[1235]    079A:                                       	        is_a_validNumber:
[1236]        :                                       	        	; you're still a shameful moron
[1237]        :                                       	        	; convert from the ascii to a usable number
[1238]    079A: B4 00                                 	        	mov ah, 0	; ah is not used, zero out
[1239]    079C: 2C 30                                 	        	sub al, '0'     ; convert ascii code into decimal number
[1240]        :                                       	        	
[1241]    079E: 83 F9 00                              	        	cmp cx, 0	; limit characters to pre-defined limit
[1242]    07A1: 74 F1                                 	        	je deletePrev
[1243]        :                                       	        	
[1244]        :                                       	        	; todo validate divisor. Must not be zero.  You can use the arrayIsZero procedure after the input has been completed
[1245]        :                                       	        	
[1246]        :                                       	        	; digits will be pushed into the stack on their correct order of magnitude
[1247]        :                                       	        	; they will later on, the popped out and inserted right to left (least significative to most significative)
[1248]        :                                       	        	; doing this to avoid this routine rightShiftUntilTheUnitDigitOfTheInputIsInTheCorrespondingUnitPositionInTheNumberArray:
[1249]    07A3: 50                                    	        	push ax			; push digit into stack
[1250]    07A4: 49                                    	        	dec cx
[1251]    07A5: E9 51 FF                              	   		jmp readingDigit	; ask for the next digit
[1252]        :                                       	   			   	
[1253]    07A8:                                       		inputIsFinished:
[1254]    07A8: 83 F9 08                              		cmp cx, length		; number cannot be empty
[1255]    07AB: 75 03 E9 49 FF                        		je readingDigit
[1256]        :                                       	
[1257]        :                                       	
[1258]        :                                       	
[1259]    07B0:                                       	popIntoNumberArray:	
[1260]        :                                       	
[1261]        :                                       	; mov si pointer into the last index of the array
[1262]    07B0: 83 C6 08                              	add si, length	; add the lenght, will excede the array by one, since arrays are zero based
[1263]    07B3: 83 EE 01                              	sub si, 1	; go back one
[1264]        :                                       	
[1265]        :                                       	; calculate the number of digits inserted
[1266]    07B6: B8 08 00                              	mov ax, length		; start with max amount of digits
[1267]    07B9: 2B C1                                 	sub ax, cx		; subtract number of digits left unsused (remaining value in cx is the number of iterations left when the loop to read digits was cut short)
[1268]    07BB: 8B C8                                 	mov cx, ax		; override the value of cx
[1269]        :                                       	
[1270]    07BD:                                       	popIntoDigitIntoArray:	; pop the digits of the number into the array                     	
[1271]    07BD: 58                                    		pop ax		; pop digit		
[1272]    07BE: 88 04                                 		mov [si], al    ; move digit into corresponding array position
[1273]    07C0: 4E                                    		dec si          ; decrease array index
[1274]    07C1: E2 FA                                 	        loop popIntoDigitIntoArray	; complete iterations to pop the remainding digits of the number into the array	
[1275]        :                                       					 			
[1276]    07C3: B8 00 00                              	mov ax, 0
[1277]    07C6: BA 00 00                              	mov dx, 0
[1278]    07C9: BE 00 00                              	mov si, 0
[1279]    07CC: BF 00 00                              	mov di, 0
[1280]        :                                       			
[1281]    07CF: C3                                    	ret
[1282]        :                                       readNumberInput ENDP
[1283]        :                                       
[1284]        :                                       
[1285]    07D0:                                       putANewLineInTheConsole proc
[1286]        :                                       	
[1287]    07D0: BA 0C 00                              	lea dx, newline	; carriage return and line feed make up a newline.
[1288]    07D3: B4 09                                 	mov ah, 09h
[1289]    07D5: CD 21                                 	int 21h
[1290]        :                                       	
[1291]    07D7: C3                                    	ret	
[1292]        :                                       putANewLineInTheConsole endp
[1293]        :                                       
[1294]    07D8:                                       putABackspaceInTheConsoleAndDeleteThePreviousCharacter proc
[1295]        :                                       	; meant to be used for data validation, when user does not press backspace key
[1296]    07D8: BA 0F 00                              	lea dx, backspace_string	
[1297]    07DB: B4 09                                 	mov ah, 09h
[1298]    07DD: CD 21                                 	int 21h	
[1299]        :                                       	
[1300]    07DF: C3                                    	ret	
[1301]        :                                       putABackspaceInTheConsoleAndDeleteThePreviousCharacter endp
[1302]        :                                       
[1303]    07E0:                                       deleteCurrentCharacter proc
[1304]        :                                       	; meant to be used when user inserts a backspace
[1305]    07E0: BA 13 00                              	lea dx, removeCurrentCharacter
[1306]    07E3: B4 09                                 	mov ah, 09h
[1307]    07E5: CD 21                                 	int 21h	
[1308]        :                                       	
[1309]    07E7: C3                                    	ret	
[1310]        :                                       deleteCurrentCharacter endp
[1311]        :                                       
[1312]    07E8:                                       outputMinusChar proc
[1313]        :                                       	
[1314]    07E8: BA 18 00                              	lea dx, negativeResultString
[1315]    07EB: B4 09                                 	mov ah, 09h
[1316]    07ED: CD 21                                 	int 21h	
[1317]        :                                       	
[1318]    07EF: C3                                    	ret	
[1319]        :                                       outputMinusChar endp
[1320]        :                                       
[1321]    07F0:                                       correctInvalidBackspace proc
[1322]        :                                       	
[1323]    07F0: BA 16 00                              	lea dx, addSpace
[1324]    07F3: B4 09                                 	mov ah, 09h
[1325]    07F5: CD 21                                 	int 21h	
[1326]        :                                       	
[1327]    07F7: C3                                    	ret	
[1328]        :                                       correctInvalidBackspace endp
[1329]        :                                       
[1330]    07F8:                                       config proc	
[1331]    07F8: B8 10 00                              	mov ax, @data	; load data segment
[1332]    07FB: 8E D8                                 	mov ds, ax      ; load data segment
[1333]        :                                       	
[1334]        :                                       	;mov ax, stack_segment	; load stack segment
[1335]        :                                       	;mov ss, ax             ; load stack segment
[1336]        :                                       	;mov sp, 0xFFFE  ; Set stack pointer to the top of the stack
[1337]        :                                       
[1338]        :                                       	
[1339]    07FD: B8 03 00                              	mov ax, 03h	; set video mode configuration 3
[1340]    0800: CD 10                                 	int 10h
[1341]    0802: B8 00 00                              	mov ax, 0	; zero ax register to not messup later (idk if it even can)
[1342]        :                                       	
[1343]    0805: C3                                    	ret
[1344]        :                                       config endp
[1345]        :                                       
[1346]    0806:                                       exitProgram proc	
[1347]    0806: B8 00 4C                              	mov ax, 4c00h   ; exit program
[1348]    0809: CD 21                                 	int 21h
[1349]        :                                       		
[1350]    080B: C3                                    	ret	
[1351]        :                                       exitProgram endp	
[1352]        :                                       
[1353]        :                                       	
[1354]        :                                       END
[1355]        :                                       
 
===================================================================================================
 
EXE HEADER - bytes from 0000 to 01FF inclusive.

0000: 4D      -   exe signature (M)
0001: 5A      -   exe signature (Z)
0002: 0C      -   bytes on last page (l.byte)
0003: 00      -   bytes on last page (h.byte)
0004: 06      -   512 byte pages in file (l.byte)
0005: 00      -   512 byte pages in file (h.byte)
0006: 01      -   relocations (l.byte)
0007: 00      -   relocations (h.byte)
0008: 20      -   paragraphs in header (l.byte)
0009: 00      -   paragraphs in header (h.byte)
000A: 00      -   minimum memory (l.byte)
000B: 00      -   minimum memory (h.byte)
000C: FF      -   maximum memory (l.byte)
000D: FF      -   maximum memory (h.byte)
000E: 00      -   SS - stack segment (l.byte)
000F: 00      -   SS - stack segment (h.byte)
0010: 00      -   SP - stack pointer (l.byte)
0011: 01      -   SP - stack pointer (h.byte)
0012: A2      -   check sum (l.byte)
0013: 40      -   check sum (h.byte)
0014: 00      -   IP - instruction pointer (l.byte)
0015: 00      -   IP - instruction pointer (h.byte)
0016: 1C      -   CS - code segment (l.byte)
0017: 00      -   CS - code segment (h.byte)
0018: 1E      -   relocation table adress (l.byte)
0019: 00      -   relocation table adress (h.byte)
001A: 00      -   overlay number (l.byte)
001B: 00      -   overlay number (h.byte)
001C: 01      -   signature (l.byte)
001D: 00      -   signature (h.byte)
001E: 39      -   relocation table - offset inside segment (l.byte)
001F: 06      -   relocation table - offset inside segment (h.byte)
0020: 1C      -   relocation table - segment anchor (l.byte)
0021: 00      -   relocation table - segment anchor (h.byte)
0022 to 01FF  -   reserved relocation area  (00) 




===================================================================================================
